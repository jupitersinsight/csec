## HTML

Browsers and Web-Application Firewalls and other pieces of software might parse HTML in different ways and where this happens, there well might be a vulnerability.

HTML5 introduced default behaviors to follow for browsers when parsing legacy HTML code, examples are:
- the **script** tag on its own will automatically be closed at the end of the page
-  a tag missing its closing angle bracket will automatically be closed by the angle bracket of the next tag on the page


________

## SOP (Same Origin Policy)

SOP is how the browser restricts a number of security-critical features:
- What domains can you contact via XMLHttpRequest
- Access the DOM across separate frames/windows

### Origin Matching

The way origin matching for SOP works is much more strict than cookies:
- Protocol must match otherwise meaning there is no crossing HTTP/HTTPS boundaries
- Port numbers must match
- Domain names must be and exact match meaning wildcards and subdomain walking are not allowed

It is possible for developers to loosen the grip that SOP has on their communications by changing document.domain, posting messages between windows and by using CORS (Cross-Origin Resource Sharing).
Every little change opens up new avenues for attack.


________

## CORS (Cross-Origin Resource Sharing)

CORS allows XMLHtppRequests outside the origin domain but with special headers.  
They even support sending and retrieval of cookies (going up to the remote server).

________

## CSRF (Cross-Site Request Forgery)

CRSF is when an attacker tricks a victim into going to a page controlled by the attacker, which then submits data to the target site _as_ the victim.  

CSRF tokens are randomnly generated and tied to users' sessions in order to prevent POST requests coming from unauthorized users (both logged-in and not logged-in).

Missing CSRF tokens in forms, of any kind, is to be considered a vulnerability, meaning a finding.

________

## Handling User Access

Handling user access is a core security problem that most web applications use a trio of interrelated security mechanisms:

- Authentication
- Session management
- Access control

Since these 3 mechanisms are intertwined, the overall mechanism is as strong as the weakest link in the chain.

### Authentication

Authentication means that the application must ensure the user's identity, meaning that he really is who he claims to be.  
A basic authentication process involves only two requirements: username and password. Critical applications like homebanking web-apps implement more robust authentication mechanism requiring additional requirements (2FA, might those be OTP password, tokens or "biometrical factors" (like fingerprints).  
Login portals today offer users supporting functionality like self-registration, password recovery and password change facility.

Even though authentication mechanisms may seem simple, they suffer from a wide range of defects in both design and implementation.  
Common problems may enable attackers to identify other users' usernames, guess their passwords or bypass the login function completely.  

Because of this, a fair amount if time should be invested into investigating the authentication-related functions a web-app contains.  

### Session management

After a user is logged-in, the logical task is to manage the authenticated user's session: a web-app receives a lot of HTTP requests both from authenticated users and anonymous users.  
Keeping tracks of each individual communication is usually achieved issuing unique session tokens to users (cookies).  
The session itself is a set of data structures held on the server that track the state of the user's interaction with the application.  
The token is a unique string that the application maps to the session.  

Browsers store cookies in a cookie jar and send them (or it) to each subsequent HTTP request and response.  
Cookies are the standard method for transmitting session tokens, although many applications use hidden form fields or the URL query strings for this purpose.  
If a user does not make a request for a certain amount of time, the session is ideally expired. 

In terms of attack surface, the session management mechanism ishigly dependent on the security of its tokens.  
The majority of attacks against it seek to compromise the tokens issued to other users, if this is possible an attacker can masquerade as the victim user and use the application as if he had actually authenticated as that user.

### Cookies

Cookies are key-value pairs sent from the server and which the client uses to perform allowed actions on that server (cookies are sent with each request).

Cookies can be set for a parent domain (.example.com) and for subdomains (sub.example.com).
- Cookies set for a parent domain can be read by its child-domains (.example.com and sub.example.com)
- Cookies set for a subdomain can only be read by the subdomain and its subdomains (sub.example.com and subsub.sub.example.com)
- A subdomain can set cookies for its own subdomains, its parent but not for siblings domains (.example.com and sub.example.com and subsub.example.com but not sub2.example.com)

For security purposes the server may sent cookies along with two tags in the **Set-Cookie** header:
- **Secure**: cookies will be accessible only on HTTPS pages
- **HttpOnly**: cookies will not be readable by Javascript

### Access control

The final logical step is to make and enforce correct decisions about whether each individual request should be permitted or denied.  

A web-app may contain numerous user roles, each granting access to subset of data (small or large), limit transactions and other checks.  
Due to the complex nature of typical access control requirements, this mechanism if a frequent source of security vulnerabilities.  

Developers often make wrong assumptions about how users will interact with the appliction and frequently male oversights by omitting access control checks from some application functions.  
Probing for these vulnerabilities is time-consuming because the same checks need to be repeated for each item of functionality but is always a worthwhile investment when attacking a web application.  

_______

## Handling User Input

All user input is untrusted.  

Web application must handle user input accordingly to the very nature of the application and the purpose of the page where user input is accepted.  

Cookies and hidden validation input needed to the back-end server must be handled in a proper way because attackers may (and will) view and modify them.  

If a web-app detects that server-generated data has been modified in a way that is not possible for and ordinary users with a standard browser, this often indicates that the user is attempting to probe the application for vulnerabilities.  
In these case, the application should reject the request and log the incident for potential investigation.  

## Approaches to Input Handling

Different approaches are often prefereable for different situations and different types of input, and a combination of approaches may sometimes be desirable.  

### Reject Known Bad

This approach makes use of blacklist to reject known bad input and allow everything else. This validation mechanism is consider to be the least effective for two main reasons.  

First of all it is impossible to include every possible malicious input or pattern. They may very well be encoded or represented in various ways.   
Second, techniques for exploitation are constantly evolving.  
Novel methods for exploiting existing categorie of vulnerabilities are unlikely to be blocked by current blacklists.  

Many blacklist-based filters can be bypassed with almost embarassing ease by making trivial adjustements to the input that is being blocked. For example:

- if ```SELECT``` is blocked, try ```SeLecT```
- if ```or 1=1--``` is blocked, try ```or 2=2--```
- if ```alert('xss')``` is blocked, try ```prompt('xss')```

Filters can be bypassed by using nonstandard characters between expressions to disrupt the tokenizing performed by the application, for example:

- ```SELECR/*foo*/username,password/*foo*/FROM/*foo*/users```
- ```<img%09onerror=alert(1) src=a>```

Finally, numerous blacklist-based filters have been vulnerable to NULL bytes. Inserting a NULL byte anywhere before a blocked expression can cause some filters to stop processing the input and therefore not identify the expression.  

```%00<script>alert(1)</script>```

In contexts where NULL bytes act as a string delimiter, it can be used to terminate a filename or a query to some back-end component.  
In contexts where NULL are tolerated and ignored (for example, within some HTML in some browsers), arbitrary NULL bytes can be inserted within blocked expressions to defeat some blacklist-based filters.  

### Accept Known Good

Whitelist-based filters are considered more effective than blacklit-based ones because only permitted input is accepted by the application.  
Carefully crafted whitelists greatly reduces the attack surface but can be bypassed (in rare and specific cases) meaning they are not an-all purpose solution.  

### Sanitization

This approach recognizes the need to sometimes accept data that cannot be guaranteed as safe. Instead of rejecting the input, the application sanitizes it in various way to prevent it from having any adverse effects.  
Potentially malicious characters may be removed from the data, leaving only what is known to be safe, or they may be suitably encoded or "escaped" before further processing is performed.

This approach is often highly effective and in many cases it can be relied on as a general solution to the problem. However, effetive sanitization may be difficult to achieve if serveral kinds of potentially malicious ata needto be accomodated within one item of input.  

### Safe Data Handling

Where applicable, making use of inherently safe processes greatly reduces risks in handling unsafe user input, for example SQL injection attacks can be prevented through the correct use of parameterized queries for database access.  
In other situations, application functionality can be designed in such a way that inherently unsafe practices, such as passing user input to an operating system command interpreter, are avoided.  

### Semantic Checks

This approach does not perform controls over malformed input data but aims to prevent, for example, unauthorized access validating user information against a database (e.g. session cookies or authorization tokens).

## Boundary Validation

Tracing a line between server-side and client-side, between what is internal (safe) and what is external (unsafe) may lead to underestimate or not foresee risks, vulnerabilities and attacks.

Given the wide range of functionality that applications implement, and the different technologies at use, a typical application needs to defend itself against a huge variety of input-based attacks. It would be very difficult to devise a single mechanism at the external boundary to defend against all these attacks.  

Many application functions involve chaining together a series of different types of processing. A single piece of user-supplied input might result in a number of operations in different components. As the data is transformed it might come to bear no resemblance to the original input.  
A skilled attacker may be able to manipulate the application to cause malicious input to be generated at a key stage of the processing, attacking the component that receives the data.  

Defending against different categories of input-based attack may entail performing different validation checks on user input that are incompatible with one another. For example, preventing cross-site scripting attacks may require the application to HTML-encode the > character as \&gt;, and preventing command injection attacks may require the application to block input containing the & and ; characters.  

Attempting to prevent all categories of attack simultaneously at the application external boundary may sometimes be impossible. 

A more effective model uses the concept of _boundary validation_.  

Each individual component or functional unit of the server-side applications treats its inputs as coming from an unstrusted source. Data validation is perfomed at each of these trust boundaries, not only between server-side and client-side.  
Each component implements defenses against maliciously crafted inputs to which it may be vulnerable and, since checks are implemented at different stages of processing, there is no conflict between them.  

## Multistep Validation and Canicalization

A common problem encountered by input-handling mechanisms arises when user-supplied is manipulated across serveral steps as part of the validation logic.  
For example, an application may attempt to sanitize user input by removing or encoding certain characters or expressions defending against a cross-site scripting attacks stripping the expression ```<script>```.  
However and attacker may be able to bypass the filter by submitting the string ```<scr<script>ipt>```. As soon as the web-app removes the substring ```<script>```, the sorrounding data contracts to restore the malicious payload because the filter is not applied recursively.  

Similarly, an attacker may be able to exploit the ordering of these steps to bypass a filter. For example, a web-app may first remove the string ```../``` and then ```..\``` recursively, check that can be bypassed using the input ```....\/```.  

A related problem arises in reation to data canonicalization.  
When input is transmitted from browsers it may be encoded in various ways, encoding schemes that exists so that unusual characters and binary data may be trasmitted safely over HTTP.  

Canonicalization is the process of converting or decoding data into a common character set. If canonicalization is performed after input filtershave been applied and attacker may be able to use a suitable encoding scheme to bypass the validation mechanism.  

For example, an application may attempt to defend against some SQL injection attacks by blocking input containing the apostrophe character.  

However, if the input is subsequently canonicalized, an attacker may be able to use double URL encoding to defeat the filter, like ```%2527```.

When this input is received, the application server performs its normal URL decode, so the input becomes ```%27```. This does not contain an apostrophe so it is permitted by the application's filters.  
But when the application performs a further URL-decode, the input is converted into an apostrophe, thereby bypassing the filter.  

If the application strips the apostrophe instead of blocking it, and then performs further canonicalization, the following bypass may be effective ```%%2727```.

Avoiding problems with multistep validation and canonicalization can sometimes be difficult and there is no single solution to the problem.  
When feasible, it is preferable to avoid attempting to clean some kinds of bad input and rejecting them altogether.  

_______

## Handling Attackers

