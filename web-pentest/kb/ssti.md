## What is a SSTI?

A server side template injection is a vulnerability that occurs when a server renders user input as a template of some sort.  

Templates can be used when only minor details of a page need to change from circumstance to circumstance.  

For example, depending on the IP that accesses a site, the site may look like:

```html
<h1>Welcome to the page!</h1>
<u>This page is being accessed from the remote address: {{ip}}</u>
```

Instead of creating a whole new page per person that accesses the site, it will simply render the remote address into the {{ip}} variable, while reusing the rest of the HTML for each person request the server receives to that endpoint.

This can be abused, since some template engines support some fairly complex functionality, that eventually allow for developers to run commands or file contents straight from the template.

So when the power to create and render templates is given to a user, it can lead to full access to the system, as the user running the webserver.

## What is 'MRO'?

Method Resolution Order (MRO) is the order in which Python looks for a method in a hierarchy of classes. It plays a vital role in the context of multiple inheritance as single method may be found in multiple super classes.

```python
class A:
    def process(self):
        print('A process()')

class B:
    def process(self):
        print('B process()')

class C(A, B):
    def process(self):
        print('C process()')

class D(C,B):
    pass

obj = D()
obj.process()

print(D.mro())
```

This script will output the following: `[<class '__main__.D'>, <class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>]`

So we can use the MRO function to display classes, will come in extremely handy for building python SSTI Jinja2 payloads. If you dislike using the `global_name.__class__.__mro__` format, you can also make use of `__base__`. For example: `global_name.__class__.__base__`.

Since MRO will list the order in which the hierarchy of classes will be handled, we can take advantage of the fact that it lists the classes, to select the one we want. On the other hand, with base, we will not get this opportunity, but it also means we can discard the use of the [1], that is used to select the object class in this payload for example: `{{g.__class__.__mro__}}` OR `{{g.__class__.mro()}}` OR `{{g['__class__']['mro']()}}` OR `{{g['__class__']['__mro__']}}`.

Essentially, `{{g.__class__.__mro__[1]}} == {{g.__class__.__base__}}`.