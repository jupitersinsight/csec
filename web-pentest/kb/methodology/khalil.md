## :black_flag: **Black Box Testing**

**Automated scans only find low-hanging fruits**  
Mapping an application it is extremely important to find real and critical vulnerabilities.  
Sending/spamming malicious payloads against an application with no prior knowledge about the application ins-and-outs is what automated scanners do.  
Manual mapping is what let you find golden treasures. 

### :mag: **Map the application**
- Access all of available pages
- Make note of input vectors talking with the backend
- Try to understand the logic behind the application
- Find subdomains related to the application
- Enumerate directories and hidden pages

**Directory Traversal**
- Identify all instances where the web application appears to contain the name of a file or directory
- Identify all functions in the application whose implementation is likely to involve retrieval of data from a server filesystem

**OS Command Injection**
- Identify all instances where the web application appears to be interacting with the underlying operating system

**SSRF**
- Identify any request parameters that contain hostnames, IP addresses or full URLs

### :hammer: **Fuzz the application**

**SQLi**
- Submit SQL-specific characters such as **'**, **"**, **#** or **--** and look for errors or other anomalies*
- Submit Boolean conditions such as **OR 1=1** and **OR 1=2**, and look for differences in the application's responses
- Submit payloads designed to trigger time delays when executed within a SQL query, and look for differences in the time taken to respond
- Submit OAST payloads designed to trigger an out-of-band network interaction when executed within an SQL query, and monitor for any resulting interactions

\* Automated scanners fuzz the application but are not able to interpret error messages and refine the payload

**Directory Traversal**
- Test identified instances with common directory traversal payloads and observe how the application responds
```
../../etc/passwd
../.htaccess
\..\Windows\win.ini
[...]
```
This process is long and tedious, so automated scanners (WAVS - Web Application Vulnerability Scanners) or fuzzers might be a good choice.

**OS Command Injection**
- Make use of shell metacharcters: **&+**, **&&**, **|**, **||**, **;**, **\n**, **`**, **$()**
- For in-band command injection, analyze the response of the application to determine if it is vulnerable
- For blind command injection, you need to be creative:
    - Trigger a time delay either via _ping_ or _sleep_ command **(No impact)**
    - Output the response of the command in the web root and retrieve the file directly using a browser **(Impact)**
    - Open an out-of-band channel to a server you control

**Access Control**
- Understand how access control is implemented for each privilege level (if possible, use two account with same privilege level to test for **horizontal privilege escalation**, and two accounts with different privilege level to test for **vertical privilege escalation**)
- Manipulate parameters that are potentially used to make access control decisions in the backend
    - It is possible to speed up the process using the extension **Autorize** for Burp

**SSRF**
- For each request parameter, modify it value to specify an alternative resource and observe how the application responds
    - If a defense is in place, attempt to circumvent it using known techniques
- For each request parameter, modify its value to a server in the internet that you control and monitor the server for incoming requests
    - If no incoming connections are received, monitor the time taken for the application to respond (due to firewall rules)


___



## :white_flag: **White Box Testing**

### **Enable Web Server logging**
### **Enable database logging**

Logs help in seeing and understanding what the application receives, what is being processed and why error messages are displayed. Having a clear picture, other than the actual application source code, is really important in finding vulnerabilities.  

### **Map the application**
- Repeat steps as if from a black-box perspective


**SQLi**
- Regex search on all instances in the code that talk to the database


**Directory Traversal**
- Identify all instances where user-supplied input is being passed to file APIs or as parameters to the operative system
    - Identify instances in a running application first (black-box perspective) and then review the code responsible for that functionality
    - Grep on functions in the code that are known to include and evaluate files on the server and review if they take user-supplied input
    - Use a tool to monitor all filesystem activity on the server. Then test each page of the application by inserting a single unique string. Set a filter in yuor monitoring tool for that specific string and identify all events that contain the string
- Validate potential directory traversal vulnerabilities on a running application

**OS Command Injection**
- Map all input vectors in the application
- Review the source code to determine if any of the input vectors are added as parameters to functions that execute system commands
- Once a vulnerability is identified, test it to confirm that it is exploitable

**Access Control**
- Review the code to identify how access control is implemented in the application
    - System defaults to open (does not deny access by default)
    - Weak or missing access control checks on functions/resources
    - Missing access control rules for POST, PUT and DELETE methods at the API level
    Relying solely on client-side input to perform access control decisions (input receives from client-side componets are not to be trusted and client-side checks can be easily bypassed)

**SSRF**
- Review the code and identify all request parameters that accepts URLs
- Determine which URL parser is being used and if it can be bypassed. Similarly determine what additional defenses are put in place that can be bypassed

### **Code Review**
- Follow the code path for all input vectors