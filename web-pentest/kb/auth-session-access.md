## Handling User Access

Handling user access is a core security problem that most web applications use a trio of interrelated security mechanisms:

- Authentication
- Session management
- Access control

Since these 3 mechanisms are intertwined, the overall mechanism is as strong as the weakest link in the chain.

### Authentication

Authentication means that the application must ensure the user's identity, meaning that he really is who he claims to be.  
A basic authentication process involves only two requirements: username and password. Critical applications like homebanking web-apps implement more robust authentication mechanism requiring additional requirements (2FA, might those be OTP password, tokens or "biometrical factors" (like fingerprints).  
Login portals today offer users supporting functionality like self-registration, password recovery and password change facility.

Even though authentication mechanisms may seem simple, they suffer from a wide range of defects in both design and implementation.  
Common problems may enable attackers to identify other users' usernames, guess their passwords or bypass the login function completely.  

Because of this, a fair amount if time should be invested into investigating the authentication-related functions a web-app contains.  

### Session management

After a user is logged-in, the logical task is to manage the authenticated user's session: a web-app receives a lot of HTTP requests both from authenticated users and anonymous users.  
Keeping tracks of each individual communication is usually achieved issuing unique session tokens to users (cookies).  
The session itself is a set of data structures held on the server that track the state of the user's interaction with the application.  
The token is a unique string that the application maps to the session.  

Browsers store cookies in a cookie jar and send them (or it) to each subsequent HTTP request and response.  
Cookies are the standard method for transmitting session tokens, although many applications use hidden form fields or the URL query strings for this purpose.  
If a user does not make a request for a certain amount of time, the session is ideally expired. 

In terms of attack surface, the session management mechanism ishigly dependent on the security of its tokens.  
The majority of attacks against it seek to compromise the tokens issued to other users, if this is possible an attacker can masquerade as the victim user and use the application as if he had actually authenticated as that user.

### Cookies

Cookies are key-value pairs sent from the server and which the client uses to perform allowed actions on that server (cookies are sent with each request).

Cookies can be set for a parent domain (.example.com) and for subdomains (sub.example.com).
- Cookies set for a parent domain can be read by its child-domains (.example.com and sub.example.com)
- Cookies set for a subdomain can only be read by the subdomain and its subdomains (sub.example.com and subsub.sub.example.com)
- A subdomain can set cookies for its own subdomains, its parent but not for siblings domains (.example.com and sub.example.com and subsub.example.com but not sub2.example.com)

For security purposes the server may sent cookies along with two tags in the **Set-Cookie** header:
- **Secure**: cookies will be accessible only on HTTPS pages
- **HttpOnly**: cookies will not be readable by Javascript

### Access control

The final logical step is to make and enforce correct decisions about whether each individual request should be permitted or denied.  

A web-app may contain numerous user roles, each granting access to subset of data (small or large), limit transactions and other checks.  
Due to the complex nature of typical access control requirements, this mechanism if a frequent source of security vulnerabilities.  

Developers often make wrong assumptions about how users will interact with the appliction and frequently male oversights by omitting access control checks from some application functions.  
Probing for these vulnerabilities is time-consuming because the same checks need to be repeated for each item of functionality but is always a worthwhile investment when attacking a web application.  

_______

## Handling User Input

All user input is untrusted.  

Web application must handle user input accordingly to the very nature of the application and the purpose of the page where user input is accepted.  

Cookies and hidden validation input needed to the back-end server must be handled in a proper way because attackers may (and will) view and modify them.  

If a web-app detects that server-generated data has been modified in a way that is not possible for and ordinary users with a standard browser, this often indicates that the user is attempting to probe the application for vulnerabilities.  
In these case, the application should reject the request and log the incident for potential investigation.  

## Approaches to Input Handling

Different approaches are often prefereable for different situations and different types of input, and a combination of approaches may sometimes be desirable.  

### Reject Known Bad

This approach makes use of blacklist to reject known bad input and allow everything else. This validation mechanism is consider to be the least effective for two main reasons.  

First of all it is impossible to include every possible malicious input or pattern. They may very well be encoded or represented in various ways.   
Second, techniques for exploitation are constantly evolving.  
Novel methods for exploiting existing categorie of vulnerabilities are unlikely to be blocked by current blacklists.  

Many blacklist-based filters can be bypassed with almost embarassing ease by making trivial adjustements to the input that is being blocked. For example:

- if ```SELECT``` is blocked, try ```SeLecT```
- if ```or 1=1--``` is blocked, try ```or 2=2--```
- if ```alert('xss')``` is blocked, try ```prompt('xss')```

Filters can be bypassed by using nonstandard characters between expressions to disrupt the tokenizing performed by the application, for example:

- ```SELECR/*foo*/username,password/*foo*/FROM/*foo*/users```
- ```<img%09onerror=alert(1) src=a>```

Finally, numerous blacklist-based filters have been vulnerable to NULL bytes. Inserting a NULL byte anywhere before a blocked expression can cause some filters to stop processing the input and therefore not identify the expression.  

```%00<script>alert(1)</script>```

In contexts where NULL bytes act as a string delimiter, it can be used to terminate a filename or a query to some back-end component.  
In contexts where NULL are tolerated and ignored (for example, within some HTML in some browsers), arbitrary NULL bytes can be inserted within blocked expressions to defeat some blacklist-based filters.  

### Accept Known Good

Whitelist-based filters are considered more effective than blacklit-based ones because only permitted input is accepted by the application.  
Carefully crafted whitelists greatly reduces the attack surface but can be bypassed (in rare and specific cases) meaning they are not an-all purpose solution.  

### Sanitization

This approach recognizes the need to sometimes accept data that cannot be guaranteed as safe. Instead of rejecting the input, the application sanitizes it in various ways to prevent it from having any adverse effects.  
Potentially malicious characters may be removed from the data, leaving only what is known to be safe, or they may be suitably encoded or "escaped" before further processing is performed.

This approach is often highly effective and in many cases it can be relied on as a general solution to the problem. However, effective sanitization may be difficult to achieve if serveral kinds of potentially malicious chars need to be accomodated within one item of input.  

### Safe Data Handling

Where applicable, making use of inherently safe processes greatly reduces risks in handling unsafe user input, for example SQL injection attacks can be prevented through the correct use of parameterized queries for database access.  
In other situations, application functionality can be designed in such a way that inherently unsafe practices, such as passing user input to an operating system command interpreter, are avoided.  

### Semantic Checks

This approach does not perform controls over malformed input data but aims to prevent, for example, unauthorized access validating user information against a database (e.g. session cookies or authorization tokens).

## Boundary Validation

Tracing a line between server-side and client-side, between what is internal (safe) and what is external (unsafe) may lead to underestimate or not foresee risks, vulnerabilities and attacks.

Given the wide range of functionality that applications implement, and the different technologies at use, a typical application needs to defend itself against a huge variety of input-based attacks. It would be very difficult to devise a single mechanism at the external boundary to defend against all these attacks.  

Many application functions involve chaining together a series of different types of processing. A single piece of user-supplied input might result in a number of operations in different components. As the data is transformed it might come to bear no resemblance to the original input.  
A skilled attacker may be able to manipulate the application to cause malicious input to be generated at a key stage of the processing, attacking the component that receives the data.  

Defending against different categories of input-based attack may entail performing different validation checks on user input that are incompatible with one another. For example, preventing cross-site scripting attacks may require the application to HTML-encode the > character as \&gt;, and preventing command injection attacks may require the application to block input containing the & and ; characters.  

Attempting to prevent all categories of attack simultaneously at the application external boundary may sometimes be impossible. 

A more effective model uses the concept of _boundary validation_.  

Each individual component or functional unit of the server-side applications treats its inputs as coming from an unstrusted source. Data validation is perfomed at each of these trust boundaries, not only between server-side and client-side.  
Each component implements defenses against maliciously crafted inputs to which it may be vulnerable and, since checks are implemented at different stages of processing, there is no conflict between them.  

## Multistep Validation and Canicalization

A common problem encountered by input-handling mechanisms arises when user-supplied is manipulated across serveral steps as part of the validation logic.  
For example, an application may attempt to sanitize user input by removing or encoding certain characters or expressions defending against a cross-site scripting attacks stripping the expression ```<script>```.  
However and attacker may be able to bypass the filter by submitting the string ```<scr<script>ipt>```. As soon as the web-app removes the substring ```<script>```, the sorrounding data contracts to restore the malicious payload because the filter is not applied recursively.  

Similarly, an attacker may be able to exploit the ordering of these steps to bypass a filter. For example, a web-app may first remove the string ```../``` and then ```..\``` recursively, check that can be bypassed using the input ```....\/```.  

A related problem arises in reation to data canonicalization.  
When input is transmitted from browsers it may be encoded in various ways, encoding schemes that exists so that unusual characters and binary data may be trasmitted safely over HTTP.  

Canonicalization is the process of converting or decoding data into a common character set. If canonicalization is performed after input filtershave been applied and attacker may be able to use a suitable encoding scheme to bypass the validation mechanism.  

For example, an application may attempt to defend against some SQL injection attacks by blocking input containing the apostrophe character.  

However, if the input is subsequently canonicalized, an attacker may be able to use double URL encoding to defeat the filter, like ```%2527```.

When this input is received, the application server performs its normal URL decode, so the input becomes ```%27```. This does not contain an apostrophe so it is permitted by the application's filters.  
But when the application performs a further URL-decode, the input is converted into an apostrophe, thereby bypassing the filter.  

If the application strips the apostrophe instead of blocking it, and then performs further canonicalization, the following bypass may be effective ```%%2727```.

Avoiding problems with multistep validation and canonicalization can sometimes be difficult and there is no single solution to the problem.  
When feasible, it is preferable to avoid attempting to clean some kinds of bad input and rejecting them altogether.  

_______

## Handling Attackers

Every application open to the public Internet will, soon or later, be targeted by skilled and dedicated attackers.  
In order to handle them, applications make use of a mixture of defensive and offensive measures design to frustrate the attacker, log the attack, notify administrators and react to the attacks.  

### Handling Errors

While designing applications, developers tend to predict errors caused by normal usage of applications' functionality and they can fix overseen problems while the app is in beta-testing (prior to deployment in a production context). What it is difficult to foresee is how malicious users may interact with the application.  

First of all, applications should never return system-generated messages or other degub information in their response. Overly verbose error messages will greatly assist attackers in succeed in their attacks. Errors and exceptions should be catched and handled in an appropriate way, like presenting an uninformative error message.  

Error handling is often integrated with the application's logging mechanisms.  

### Maintaning Audit Logs

Effective audit logs should enable the application's owner to understand what has taken place, what vulnerabilities (if any) were exploited, whether the attacker gained access and what actions performed and, sometimes, even provide evidence of the intruder's identity.  

At a minimum, applications should log:
- all events relating to the authentication functionality, successful and failed login;
- key transactions, such as credit card payments and funds transfers;
- access attempts that are blocked by access control mechanisms;
- any requests containing known attack strings that indicate overtly malicious intentions

In order to block attackers from altering logs content, logging system should receive updates only from the application, should block write and read attempts from other entities.  
Where needed it is a good idea to flush logs to write-once media.  

In case of poorly protected logs, they may provide extremely useful to attackers since they include session token, parameters, usernames, passwords, IP addresses and more.  

### Alerting Administrators

Alerting administrators may mitigate in early stages the actions made by the attackers by blocking its IP address, the user he is using o in extreme cases taking the application offline.  
Intrusion prevention systems and web application firewalls offes useful functionalities with no great need of customized configurations but, since each web application is "unique", they tend to protect against common attacks and attack vectors.  

Alerting mechanisms embedded in the application, like for input handling, may be more effective since they are tailored on that specific application and tend to produce less false-positives than IPSes and WAFs.  

### Reacting to Attacks

Well-designed applications are able to detect malicious input and activate counter-measures to frustrate the attacker like increasing the time of responses (meaning slowing down responses to attacker's requests) or terminating his session forcing him to log-in again.  
These measures help administrators to gain time for monitoring the situation and take more drastic action if required.  

_______

## Managing the application

In many applications, administrative functions are implemented within the application itself, accessible through the same web interface as its core nonsecurity functionality. Where this is the case, the administratve mechanism represents a critical part of the application's attack surface.  
Its primary attraction for an attacker is as a vehicle for privilege escalation:
- weaknesses in the authentication mechanism may enable an attacker to gain administrative access;
- many applications do not properly implement access controls of their administrative functions, an attacker may find a way to create a new administrator account;
- cross-site scripting flaws within the administrative interface can lead to compromise of a user sessions that is guaranteed to have powerful rights;
- administrative functionality is often subjected to less rigorous security testing because its users are deemed to be trusted, if an attacker may access command prompts or reserved upload areas he may well take control over the entire server.

