Answers can be found at http://mdsec.net/wahh

## Chapter 2 - Core Defense Mechanisms
___

**Question #1**

_Why are an application's mechanisms for handling user access only as strong as the weakest of these components?_

**Answer**

Application's mechanisms for handling user access share a tight bond between them.  

They are usually identified as _Authentication_, _Session Management_ and _Access Controls_.

If _Authentication_ is not strong enough, attackers may simply brute-force it and gain access as administrative user. Once logged-in as administrators they can maintain their session active as long as the session token expires and perform whatever administrative actions the access controls allow them to.

If _Session Management_ is not properly implemented and handled, attackers may steal other users' session tokens and impersonate them. In case attackers take over administrators sessions they are already authenticated and can perform administrative actions.

If _Access Controls_ are not properly implemented or are not effective, attackers may access administrative interfaces or reserved areas and/or perform actions that should be disallowed.

The compromise of one of the three mechanisms bypass the other two entirely.

___

**Question #2**

_What is the difference between a session and a session token?_

**Answer**

Authenticated users and guests both establish sessions between their browser and the web application.  
In order to keep tracks of these sessions, web applications make use of session tokens which help in delivering the correct response to the right user and avoid mistakes (e.g. deliver response to a wrong user).

___

**Question #3**

_Why is it not always possible to use a whitelist-based approach to input validation?_

**Answer**

Taking as example IT forums where users are supposed to share code, blocking it will be of no use to the users. In this case the web application is to accept unstrusted input and use secure procedures to safely store it on the server, maybe on a dedicated server where no other critical applications, like databases, are running or in use.

___

**Question #4**

_You are attacking an application that implements an administrative function. You do not have any valid credentials to use the function. Why should you nevertheless pay close attention to it?_

**Answer**

Because the function may react to unexpected input in ways the developers never intended:
- It may have been through a less rigorous testing because the intended users are trusted;
- It may be weak in the authentication mechanism and be vulnerable to brute force;
- It may be vulnerable to XSS (store XSS) being this way a mean to attack administrators and steal sensitive information.

___

**Question #5**

_An input validation mechanism designed to block cross-site scripting attacks performs the following sequence of steps on an item of input:_

1. _Strip any ```<script>``` expressions that appear_.
2. _Truncate the input to 50 characters_.
3. _Remove any quotation marks within the input_.
4. _URL-decode the input_.
5. _If any items were deleted, return to Step 1_.

_Can you bypass this validation mechanism to smuggle the following data past it?_
```"><script>alert("foo")</script>```

**Answer**

The following payload should do the trick... ```%22%3E%3Cscript%3Ealert(%22foo%22)</script>```

Step 1 should not detect any ```<script>``` tag.  
Step 2 does nothing because the overall length of the payload is shorter than 50 characters.  
Step 3 should not detect any quotation marks.
Step 4 will URL-decode the input
Step 5 should not trigger a new run of the process because no item was removed

___

## Chapter 3 - Web Application Technologies

___

**Question #1**

_What is the `OPTIONS` method used for?_

**Answer**

The `OPTIONS` method is used to query the remote web server about supported HTTP methods for a specific resource which are returned in the response.

___

**Question #2**

_What are the `If-Modified-Since` and `If-None-Match` headers used for?_  
x_Why might you be interested in these when attacking an application?_

**Answer**

When a web application allows clients to store cached data about a requested resource, the client will inform the web application about it in requests to come.  

The `If-Modified-Since` header is used to inform the web server when the client accessed the requested resource last time. If the cached copy is still valid the server responds the client's request with a 304 status code.

The `If-None-Match` header contains an entity tag issued by the server to the client. The entity tag is per resource and determines whether the client may use its cached copy of it or not.

___

**Question #3**

_What is the significance of the `secure` flag when a server sets a cookie?_

**Answer**

The flag `secure` means that the cookie must be transmitted only over HTTPS communications to prevent MiTM-style attack against cookies.

___

**Question #4**

_What is the difference between the common status codes 301 and 302_

**Answer**

Status code 301 means that the requestes resource is no longer available at the requested path and has been _Moved Permanently_ to another URL, specified in the _Location_ header. The client must use the new URL in subsequent requests.

Status code 302 means that the requestes resource is found and the web application triggers a redirection to another path. The client must use the original URL in sebsequent requests.

___

**Question #5**

_How does a browser interoperate with a web proxy when SSL is being used?_

**Answer**

The client browser cannot perform a SSL handshake with the proxy server because it would break the secure channel. Instead, it sends a `CONNECT` request to the proxy over HTTP with destination's hostname and port. If the proxy server allows the communication to pass, it responds with a status code 200. The client browser performs the SSL handshake with the intended destination and the proxy server acts a pure TCP-level relay letting packets to flow in both directions.

___

## Chapter 4 - Mapping the Application

___

**Question #1**

_While mapping an application, you encounter the following URL:_  
`https://wahh-app.com/CookieAuth.dll?GetLogon?curl=Z2Fdefault.aspx`  

_What information can you deduce about the technologies employed on the server and how it is likely to behave?_ 

**Answer**

The resource _CookieAuth.dll_ indicates a Windows-based Web Server since .dll files are native library for Windows.  
The file extension then, _aspx_, indicates ASP.NET being in use.  

The .dll file seems to be in charge of performing session authentication based on cookies, either setting cookies or retrieving cookies.  
_curl_ command is used to perform HTTP requests, in this case, since options seem to be missing, it might just GETting the .aspx file.

**Answer from Authors**  

The filename CookieAuth.dll indicates that Microsoft ISA server is being used.  
This is the URL for the login function, and after a successful login the application will redirect to the URL /default.aspx.
___

**Question #2**

_The application you are targeting implements web forum functionality. Here is the only URL you have discovered:_  
`http://wahh-app-com/forums.ucp.php?mode=register`  

_How might you obtain a list of forum members?_

**Answer**

The URL syntax may indicate the use of phpBB as the software powering the forum board.  
Admins can surely view a list of all registered users.  

**Answer from Authors**  

The URL is a common fingerprint for the phpBB web forum software. Information about this software is readily available on the Internet, and you can perform your own installation to experiment on. A listing of members can be found at the following URL:

http://wahh-app.com/forums/memberlist.php

Individual user profiles can be found via URLs like the following:

http://wahh-app.com/forums/profile.php?mode=viewprofile&u=2

Various vulnerabilities have been found in the phpBB software so you should confirm the version in use and research any associated problems

___

**Question #3**

_While mapping an application, you encounter the following URL:_  
`https://wahh-app.com/public/profile/Address.asp?action=view&location=default`  

_What information can you infer about server-side technologies? What can you conjecture about other content and functionality that may exist?_

**Answer**

The web server may be running Microsoft because it supports .asp files.  
The URL indicates a common functionality which consists into viewing details about an address. There may well be other actions such as, _add_, _delete_, _create_...  
Other than the _Address.asp_ resources there may be .asp file for uploading an avatar picture to the profile, or for changing the email and other information compelling the user profile.

**Answer from Authors**  

The .asp file extension indicates that Microsoft’s Active Server Pages are in use.  

The use of a /public path indicates that other interesting paths might exist, such as /private.  
The action=view parameter suggests that other actions may exist, such as edit, add or delete.  
The function of the location=default parameter should be investigated – this may contain a filename, and you should probe the application for path traversal vulnerabilities.

___

**Question #4**

_A web server's responses include the following header._  
`Server: Apache-Coyote/1.1`  

_What does this indicate about the technologies in use on the server?_

**Answer**

The _Server_ header, if not configured as a sort of "honey pot" element to draw hackers' attention to a potentially sensitive but fake information, indicates the use of the _Apache_ Coyote Connector. It enables _Catalina_, which is a MacOS version, to function as a stand-alone web server.  
It also has the ability to serve servlets and JSPs.  

**Answer from Authors** 

If the header is accurate, it indicates that the server is running Apache Tomcat. Tomcat is a Java Servlet Container, so the application probably uses Java and JSP technologies

___

**Question #5**

_You are mapping two different web applications, and you request the URL `/admin.cpf` from each application. The response headers returned by each request are shown here. From these headers alone, what can you deduce about the presence of the requested resource within each application?_

```http
HTTP/1.1 200 OK
Server: Microsoft-ISS/5.0
Expires: Mon, 20 Jun 2011 14:59:21 GMT
Content-Location: http://wahh-app-com/includes/error.htm?404;http://wahh-app.com/admin.cpf
Date: Mon, 20 Jun 2011 14:59:21 GMT
Content-Type: text/html
Accept-Ranges: bytes
Content-Length: 2117
```

```http
HTTP/1.1 401 Unauthorized
Server: Apache-Coyote/1.1
WWW-Authenticate: Basic realm="Wahh Administration Site"
Content-Type: text/html;charset=utf-8
Content-Length: 954
Date: Mon, 20 Jun 2011 15:07:27 GMT
Connection: close
```

**Answer**  

The first response has a 200 OK status code which means the GET request was successful and the resource is there, exists.  
The header _Content-Location_ should contain an alternate location for the returned data (indicating the URL of a resource transmitted as the result of content negotiation). 

The second response has a 401 Unauthorized status code which means the request was sent from an unprivileged source. The resource does exists on the server.

**Answer from Authors**  

The first response uses the HTTP status code 200, which normally indicates that the request was successful. However, the Content-Location header indicates the location from which the response was retrieved. This appears to be a dynamically generated error page, and includes the value 404 in its query string, indicating that the response contains a customized “file not found” message.

The second response uses the HTTP status code 401, which suggests that the requested resource is present but that users must supply HTTP authentication credentials in order to access it.

In each case, you could substantiate your conclusion by requesting a clearly non-existent item in the same directory with the same extension (for example, /iuwehuiwefuwedw.cpf) and comparing the responses. In the first application, you would expect to see a response very similar to the original. In the second application, you would expect to see a different response containing a “file not found” message.

___

## Chapter 5 - Bypassing Client-Side Controls

___

**Question #1**  

_How can data be transmitted via the client in a way that prevents tampering attacks?_

**Answer**  

Data coming clients cannot be trusted because what is client-side is under control of users.  
Data received should always be checked against a server-side component holding secure data. If data does not match, then it is discarded.  
But again, there is no safe method to prevent clients from tampering data.  

**From authors**  

The data can be encrypted or hashed using a key stored on the server, as is optionally done for the ASP.NET ViewState. Unless an
attacker somehow captures the key, they will be unable to encrypt arbitrary data or compute a valid hash for arbitrary data. However,
the attacker may still be able to take data from one context and replay it in another – for example, the encrypted price for a cheap
item could be submitted in place of the encrypted price for an expensive item. To prevent this attack, the application should include
sufficient context within the protected data to be able to confirm that it originated in the same context as it is being employed – for
example, the product code and price could be combined in a single encrypted blob.

___

**Question #2**  

_An application developer wants to stop an taacker from performing bruteforce attacks against the login function. Because the attacker may target multiple usernames, the developer decides to store the number of failed attempts in an encrypted cookie, blocking any request if the number of failed attempts exceeds five. How can this defense be bypassed?_  

**Answer**  

The attacker should try to decrypt the cookie, modifying the number of failed attempt to 0 or 1, encrypt the cookie again and attach the cookie to each request sent.  
Without breaking the encryption, the attacker can capture the cookie from the second or third request and attach it requests, keeping the number of failed attempts at 2 or 3.  
If cookies are not per account but per client, meaning per IP address, leading to a maximum of 5 total attempts per single IP... the attacker can perform a successful login every 5 attempts (to its own account if can register one) resetting the counter to 0.  

**From authors**  

The defense is trivial to bypass. An attacker does not need to submit the cookie that tracks the number of failed login attempts. They
can either disable cookies in their browser, or use an automated script that submits requests without the relevant cookie

An alternative defense would be to use CAPTCHA controls to slow down an attacker, or to block the source IP address after five failed
logins, although this may have an adverse impact where multiple clients are located behind a proxy or a NAT-ting firewall.

___

**Question #3**

_An application contains an administrative page that is subject to rigorous access controls. It contains links to diagnostic functions located on a different web server. Access to these functions should also be restricted to administrators only. Without implementing a second authentication mechanism, which of the following client-side mechanisms (if any) could be used to safely control access to the diagnostic functionality? Do you need any more information to help choose a solution?_

1. _The diagnostic functions could check the HTTP `Referer` header to confirm that request originated on the main administrative page_
2. _The diagnostic functions could validate the supplied cookies to confirm that these contain a valid session token for the main application_
3. _The main application could set an authentication token in a hidden field that is included within the request. The diagnostic function could validate this to confirm that the user has a session on the main application_

**Answer**

Option 2 may be a good decision. Cookies should be protected using flags _Secure_ and _HttpOnly_ and can ensure only authorized users can 

Assuming authentication mechanisms are strong enough to protect the administrative page, those function links might be vulnerable to access controls bypass. Implementing authorization controls mechanisms such as cookies help in securing the access only to authorized users.  

If the authentication mechanism protecting the administrative page is bypassed, the attacker will have full access to those links.  

**From authors**  

 (a) The Referer header can be set to an arbitrary value by an attacker, and so is not a safe means of performing any access control
checks.  

(b) This method will only be effective if the web server containing the diagnostic functions is in a parent or child domain of the
originating web server, and the session cookie is appropriately scoped, otherwise the cookie will not be submitted to the diagnostic
server. A back-end mechanism will need to be implemented for the diagnostic server to validate the submitted tokens with the
originating server.  

(c) This method will be effective regardless of the domain name of the diagnostic server. It may be regarded as safe provided that the
authentication tokens are not predictable and are transmitted in a secure manner (see Chapter 7). Again, a back-end mechanism for
validating tokens will need to be implemented

___

**Question #4**

_If a form field includes the attribute `disabled=true`, it is not submitted with the rest of the form. How can you change this behavior?_

**Answer**  

Intercepting the request via a proxy-client such as BurpProxy, the attacker can alter the HTTP request before it reaches the destination.

**From users**  

There are two basic methods:  

(a) You can intercept the request containing the form submission, and add the disabled parameter.  

(b) You can intercept the response containing the form, and remove the disabled=true attribute.

___

**Question #5**  

_Are there any means by which an application can ensure that a piece of input validation logic has been run on the client?_

**Answer**  

There are no means to determine whether a piece of logic has been run on the client. What is client-side is local to the client.

**From authors**  

There is no means by which an application can ensure that a piece of logic has been run on the client. Everything that occurs on the
client is within the control of the user.
