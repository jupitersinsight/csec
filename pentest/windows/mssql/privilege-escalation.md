# Escalating Privileges within SQL Server

In questo contesto si intende privilege escalation il passaggo da utente non autenticato o utente di dominio a SQL Login.  
Un primo approccio potrebbe tradursi in un dictionary attack usando credenziali comuni, o raccolte durante altre fasi del penetration test, facendo attenzione a non bloccare gli account target.  

![image](https://user-images.githubusercontent.com/110602224/201948935-3def49f3-65a7-4a18-a689-7b7eb5d584ea.png)  
(Unauthenticated user (U) e domai user (D) perspective)

Connessione manuale al SQL Server  
![image](https://user-images.githubusercontent.com/110602224/201950392-203d491c-f348-4669-8848-29d42149e08a.png)

Molte installazioni di SQL Server Express come backend sono preconfigurate dai vendor dei prodotti software e capita che abbiano in uso credenziali standard o comunque semi note.  

![image](https://user-images.githubusercontent.com/110602224/201951207-8c206181-27d0-4a29-8354-599d96a1b307.png)  
(D)  

Se si sta usando un utente locale o di dominio è sempre consigliato effettuare un tentativo di login al database usando l'utente corrente in quanto potrebe avere accesso sia perché è giusto che sia consifurato così in base a determinate esigenze, sia che abbia privilegi di accesso dovuti a una misconfigurazione dei permessi.  

![image](https://user-images.githubusercontent.com/110602224/201952359-b70327e0-e80a-4f29-9635-f635bb8d5865.png)  
(D) (Local user perspective (L))  

Link a Wiki per uso di PowerUpSQL:https://github.com/NetSPI/PowerUpSQL/wiki  

È possibile che in determinati contesti le comunicazioni del SQL Server non sia criptate e quindi si possono intercettare e alterare le queries ponendosi come MiTM.  
Il tool [sqlmitm.py](https://gist.github.com/anonymous/edb02df90942dc4df0e41f3cbb78660b) di [Anitian](https://www.anitian.com/) è uno strumento utile nel modificare al volo le queries SQL.  

Una volta ottenuto un login in SQL (SQL Login) si inizia la fase di privesc per ottenere un livello di sysadmin.  
Al fine di raggiungere il risultato prestabilito è necessario tenere in considerazioni altri punti deboli dei DBMS:  
- password deboli ed enumerazione "blind" dei login al SQL Server
- privilegio di impersonare un altro utente
- procedure memorizzate (stored procedures) e trigger creation/injection issues
- esecuzione automatica delle stored procedures  

#### Weak Passwords and Blind SQL Server Login enumeration  
L'enumerazione dei SQL Server Login condotta in una fase iniziale restituisce un risultato parziale.  
![image](https://user-images.githubusercontent.com/110602224/201961863-51fe3989-5ad7-4124-8c41-bea735dc3415.png)

La funzione _suser\_name_ restituisce il principal name per un dato principal id.  
È quindi possibile identificare tutti gli SQL Login facendo un fuzzing del valore del principal id usando un utente con ruolo pubblico (public role).  
![image](https://user-images.githubusercontent.com/110602224/201962399-69d41114-483a-479d-97b5-f5b26ed1d39c.png)

Per i Login identificati è possibile tentare di trovare le password deboli.  
Se questo approccio fallisce si può ricorrere a un blind domain account/objects enumeration sempre da utente con public role.  

Individuazione del dominio in cui è in uso il SQL Server  
![image](https://user-images.githubusercontent.com/110602224/201963085-f0d9fb29-ab16-4231-b08b-162c93d1c5cf.png)

Ottenimento dell'intero RID del gruppo Domain Admins  
![image](https://user-images.githubusercontent.com/110602224/201963197-ec012748-cf8c-4d6f-a24f-e7678013629a.png)

Recuperare i primi 48 byte dell'intero RID per ottenere il SID del dominio.  
Per creare un nuovo RID che sarà associato a un domain object aggiungere in coda al SID un valore esadecimale.  
Infine usare la funzione _suser\_name_ per ottenere il nome del domain object associato al RID.  
![image](https://user-images.githubusercontent.com/110602224/201964172-a44feca8-7d16-4d30-a757-edfff6c3cc1c.png)

Blind SQL Login Enumeration = tool = PowerUpSQL **Get-SQLFuzzServerLogin**.  
Blind Domain Account Enumeration = tool = PowerUpSQL **Get-SQLFuzzDomainAccount**.  

Blind SQL Login Enumeration.  
![image](https://user-images.githubusercontent.com/110602224/201964932-a75270e4-7b3d-47c8-967b-a8644a9d95e7.png)

Blind Domain Account Enumeration.  
![image](https://user-images.githubusercontent.com/110602224/201968201-7c39757d-ef66-457f-ba43-21001beb7117.png)


#### Impersonation
Esistono diversi metodi per impersonare un altro utente in SQL Server.  
![image](https://user-images.githubusercontent.com/110602224/201968814-32128074-321a-46db-82bc-fde2428554bd.png)

Di seguito sono presi in considerazione:  
1) Impersonate Privilege
2) Stored Procedures and Trigger/Creation/Injection Issues
3) Automatic Execution of Stored Procedures  

(1) In SQL esiste un privilegio/permesso che permette a un utente con privilegi limitati di impersonarne uno con privilegi elevati.  
Il solo prerequisito da soddisfare per eseguire comandi a livello di OS è che il database deve essere configurato come trustworthy (affidabil).  
Esempio di controllo per impersonare l'utente _sa_.  
![image](https://user-images.githubusercontent.com/110602224/201969917-ce51cc84-ad80-4a9b-9ab3-1cbc0e9f4f6f.png)

(2) Generalmente gli sviluppatori raccolgono in una stored procedure tutte le funzionalità che vogliono che l'utente esegua in una specie di contesto di sicurezza con privilegi elevati.  
La sua esecuzione è di solito fatta dagli sviluppatori come proprietario del database (EXECUTE AS OWNER).  
In questo modo l'esecuzione può comunque avvenire nel contesto di un altro utente, i comandi possono essere limitati e non è necessario configurare il privilegio per impersonare un altro utente.  
Da un punto di vista della sicurezza ci sono alcuni svantaggi.  

Il primo è che non c'è possibilità di un controllo granulare sui privilegi del proprietario del database.  
Il secondo è che di solito quanto di installano applicazioni di questo tipo automaticamente sono assegnati come proprietari l'account sa o l'account sysadmin.  
Il ruolo DB\_OWNER può usare l'attributo EXECUTE AS OWNER per effettivamente eseguire comandi nel contesto dell'account sa o sysadmin.  
Infine, se le stored procedures sono implementate in maniera non sicura, è possibile che attraverso un attacco SQL Injection l'hacker riesca a impersonare un altro utente e a modificare la stored procedure stessa.   

Esempio di Stored Procedure  
![image](https://user-images.githubusercontent.com/110602224/202412784-56e8dd42-0ddb-4d3b-a295-05c3b66ccd16.png)

Ancora una volta, prima di potere eseguire comandi a livello di sistema operativo è necessario che si soddisfino alcuni requisiti.  
Il database deve essere configurato come affidabile (trustworthy).   
Il modo migliore per procedere è attraverso le Store Procedure firmate anche se altri modi sono impersonare altri utenti o command injection sfruttando le query SQL.  

Esempio di funzionamento di DBA per applicazione web.  
![image](https://user-images.githubusercontent.com/110602224/202414731-80aeb136-2040-453a-81bc-a0915fb763c3.png)

Scenario: durante un internal penetration test, il tester ha individuato un SQL Login valido o ha individuato un punto suscettbile a un attacco SQL injection.  
Lo step successivo consiste nell'individuare i database con owner un sysadmin E database configurati, con flag, come trustworthy.  
![image](https://user-images.githubusercontent.com/110602224/202415775-47f84a4e-bf37-47c0-9445-299a1c8518da.png)

![image](https://user-images.githubusercontent.com/110602224/202420561-fce4280b-4a1c-475e-86b6-1ad620a05903.png)

A questo punto dovrebbe essere possiile eseguire comandi del sistema operativo nel server SQL.  

Sia la fase di reconnaissance sia la fase di exploitation possono essere automatizzate usando i moduli di Metasploit _auxiliary/admin/mssql/mssql\_escalate\_dbowner_ e _auxiliary/admin/mssql/mssql\_escalate\_dbowner\_sqli_.  

[slide81]
