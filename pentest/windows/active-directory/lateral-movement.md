# Lateral Movement in Active Directory

### Concetti fondamentali
#### Access Tokens
Oggetti che descrivono il contesto di sicurezza (security context) di processi o thread.  
Il token include informazini sull'identità e privilegi degli account utenti associati con processi o thread.  
Quando un utente accede a un sistema, lo stesso genera un access token e i processi eseguiti per conto di questo utente mantengono una copia del token.  

#### Named Pipes
I named pipes permettono la comunicazione dei processi in stile FIFO (First-In First-Out) tramite il protollo SMB.  
Possono operare in modo _one-way_ o _duplex_ quindi ascoltando e richiedendo connessioni.  

#### Windows Logon Scenarios
Per accedere a Windows è necessario che gli utenti facciano uso di account validi per accedere al sitema e alle risorse.  
Dopo il primo accesso, entrano in gioco i processi di autorizzazione e controllo accesso per determinare se l'account utente usato è autorizzato per accedere alle risorse.  

Servizi e applicazioni potrebbero richiedere che gli utenti eseguano il login, in questi casi le informazioni di logon sono memorizzate nel database _Security Account Manager (SAM)_ nel computer locale o Active Directory.  
I principali scenari sono:
- Interactive Logon
- Network Logon
- Smart card Logon
- Biometric Logon  

**Interactive Logon**  
![image](https://user-images.githubusercontent.com/110602224/201311867-c6bed9ca-8317-4607-834c-908ebc867ce9.png)

Si ha un interactive logon quando gli utenti usano un set di credenziali locali o di dominio per accedere a un computer a cui hanno accesso fisico o è parte di un sistema di Desktop Remoti.  

**Network Logon**  
Generalmente invisibile all'utente finale, questo processo di autenticazione fa uso del set di credenziali usate l'interactive logon o altre.  
In questo caso i meccanismi di autenticazione sono:  
- Protocollo Kerberos v5
- Certificati con chiave pubblica  
- SSL/TLS  
- Digest  
- NTLM (retrocompatibile con sistemi basati su NT 4.0)  

Durante un network logon le credenziali non sono inviate al sistem remoto, questo causa il problema noto come _double-hop problem.  
Un comando che richiede accesso a una risorsa di rete è eseguito tramite un network logon fallisce in quanto nel computer di destinazione non è presente il set di credenziali.  

**Double-Hop Problem**  
I network logon non inviano le credenziali alla macchina di destinazione e di conseguenza il processo non può autenticarsi nel sistema remoto e accedere alla risorsa di rete.  
Tool utili per aggirare il problema sono:  
- [Server SMB di Impacket](https://github.com/SecureAuthCorp/impacket/blob/master/examples/smbserver.py): può ospitare payloads senza richiedere autenticazione utente, evitando in questo anche di trasferire il payload al computer remoto.  
- [Invoke-TmpDavFS](https://github.com/p3nt4/Invoke-TmpDavFS): memory-backed server WebDAV in Powershell per ospitare payload  
- [WsgiDAV](https://github.com/mar10/wsgidav): si può usare come server WebDAV standalone, senza autenticazione utente  

Risorse extra per approfondire l'argomento:  
- [Making the second hop in PowerShell Remoting](https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/ps-remoting-second-hop?view=powershell-7)  
- [Offensive Lateral Movement](https://hausec.com/2019/08/12/offensive-lateral-movement/)  


### PSEXEC
PsExec è un tool di Microsoft usato per eseguire programmi in un computer remoto.  
Questo è possibile perché estrae dalla sua immagine un servizio con Windows integrato chiamato PsExecSv e la copia nella share Admin$ nel sistema remoto.  
Per avviare il servizio usa il Windows Service Control Manager API. 
I comandi sono inviati tramite named pipe: psexecsv.  
Non si tratta di un metodo stealth. 

Per default il processo eseguito nel computer remoto impersona l'account che esegue PsExec. Non essendoci passaggio di credenziali al sistema remoto il double-hop problem previene che il processo acceda a risorse di rete.  
Se invece sono specificate credenziali presenti nel sistema remoto questo problema non si presenta.  
Nella versione 2.1 le credenziali sono inviate in plain-text e quindi possono essere intercettare facilmente.  

È integrato in molti moduli C2 per lateral movement ma si può usare anche nei seguenti modi:  
- [PsExec](https://learn.microsoft.com/en-us/sysinternals/) come parte dei tool Sysinternals
- [PsExec.py](https://github.com/SecureAuthCorp/impacket) come parte di impacket  
- [SharpExec -PSExec](https://github.com/anthemtotheego/SharpExec) permette di inviare comandi, eseguirli o caricale file nei computer remoti come SYSTEM  

![image](https://user-images.githubusercontent.com/110602224/201318201-1dc32f63-42d8-4859-bfc8-8e2645026a91.png)


### SC (Service Control)
Il comando SC si usa per avviare, fermare, interrogare, o eliminare i servizi di Windows in un computer locale o in un computer remoto tramite SMB.  
L'eseguibile deve essere assolutamente un service binary file altrimenti il Service Control Manager (SCM) non ne autorizza l'esecuzione e ogni comando fallisce.  

[smbexec.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/smbexec.py) di Impacket e [SharpExec -SMBExec](https://github.com/anthemtotheego/SharpExec) automatizzano il processo eseguendo comandi via sc e recuperando l'output via SMB.  
![image](https://user-images.githubusercontent.com/110602224/201318999-31e12403-07bb-49b5-8cd3-e2ecb6fe9481.png)

Invece di creare nuovi servizi (che potrebbero attirare attenzioni indesiderate), è possibile posizionare DLL appositamente create che sostituiscono DLL legittime e avviate da servizi legittimi.  
In questo modo si può fare lateral movement in maniera stealth.  
Per individuare punti deboli nei servizi bisogna monitorare le chiamate (calls) LoadLibrary per trovare eventuali errori di file non trovati nel sistema.  
Proof-of-Concept:  
- https://github.com/djhohnstein/wlbsctrl_poc
- https://github.com/djhohnstein/TSMSISrv_poc

![image](https://user-images.githubusercontent.com/110602224/201319781-90b2a216-7224-4e3f-a74e-812988e67799.png)


### Schtasks.exe
Eseguibile/comando per gestire le attività pianificate nel computer locale o remoti.  
La connessione iniziata sulla porta 137/TCP e poi prosegue in porte _ephemeral_ (tra 1024-65535).  
![image](https://user-images.githubusercontent.com/110602224/201322215-7ff2ae20-c149-4843-b56f-69e411e713e3.png)


### AT
_AT_ si può usare per programmare comandi che devono essere eseguiti in momenti precisi.  
È l'equivalente dei cronjobs di Linux con la differenza che si può usare in sistemi remoti.  
Disattviato da Windows 8.1 in poi, si può riattivare modificando il Registro di Sistema.  
![image](https://user-images.githubusercontent.com/110602224/201323213-25fb0cf2-a2bf-4f79-b201-98103c594d89.png)

I tool reg.py e atexec.py di Impacket servono lo stesso scopo.  


### WMI
L'eseguibile wmic.exe permette di accedere componenti di Windows in computer remoti usando comunizioni via RPC sulla porta TCP 135 e successivamente su ephemeral ports.  
Tra le varie operazioni che si possono eseguire, avvio di servizi o esecuzione di comandi.  
Alternative sono:  
- l'eseguibile wmic.exe di [impacket](https://github.com/SecureAuthCorp/impacket) è modificato da supportare autenticazione via hash NTLM o Kerberos  
- [SharpExec -WmiExec](https://github.com/anthemtotheego/SharpExec)  
![image](https://user-images.githubusercontent.com/110602224/201324177-d74a8e80-7807-4564-a8dd-e3197d99c6ad.png)

![image](https://user-images.githubusercontent.com/110602224/201324246-9c0d1e37-d0e7-428b-8e14-3281d1d426fa.png)

La PoC [Invoke-WMILM](https://github.com/Cybereason/Invoke-WMILM) mostra diversi metodi e tecniche compresa quella dell'immagine sopra per autenticarsi ed eseguire codice remoto.  


### PoisonHandler
[PoisonHandler](https://github.com/Mr-Un1k0d3r/PoisonHandler) è un tool che permette di creare un handler personalizzato nel sistema remoto e di usarlo come porta di accesso per l'esecuzione di altro codice.  
![image](https://user-images.githubusercontent.com/110602224/201325202-bd50c8b4-9d1d-463b-9e12-1aa30a8f9eee.png)


### Remote Desktop Services
Servizi per Desktop Remoto permettono agli utenti di accedere risorse in un computer remoto usando il protocollo RDP (Remote Desktop Protocol).  

**Pass the Hash over RDP**  
Tecnica sfruttabile se il server remoto è configurato per usare _Restricted Admin Login_, feature che previene la memorizzazione le credenziali RDP in memoria.  
Usando FreeRDP in sistemi Linux:  
![image](https://user-images.githubusercontent.com/110602224/201326146-25ebda79-a820-451c-a055-3c75ec2efb77.png)

In sistemi Windows usando il client nativo di RDP serve anche mimikatz:
![image](https://user-images.githubusercontent.com/110602224/201326566-0a2fc7e8-60db-4dd9-8b68-37ee3c48611d.png)

Nel caso in cui la modalità _Restricted Admin mode_ è disattivata nel sistema si verifica un errore ma è possibile attivarla usando mimikatz.  
![image](https://user-images.githubusercontent.com/110602224/201327358-8b08cc9c-e802-41fc-925a-5b3ac58b390e.png)
![image](https://user-images.githubusercontent.com/110602224/201327377-a3dd04ff-e2b0-48b7-9c04-efa94d33ef81.png)

La libreria dei terminal services (mstscax.dll) è accessibile sia per controlli scriptabili (web clients e script) sia per controlli non scriptabili (native o managed code).  
[SharpRDP](https://github.com/0xthirteen/SharpRDP)si basa su controlli non scriptabili della libreria COM e si può usare per eseguire codice remoto (con autenticazione) si fornendo credenziali plain-text sia via restriced admin mode.  
Una volta autenticato, SharpRDP apre un prompt "esegui" e invia keystrokes virtuali al sistema remoto usando il metodo SendKeys per eseguire i comandi.  
Quando viene scritto nel prompt "Esegui", quindi comandi in questo caso, lascia traccia nel Registro di Sistema in HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU.  
Il tool [CleanRunMRU](https://github.com/0xthirteen/CleanRunMRU) pulisce la chiave di registro.  

![image](https://user-images.githubusercontent.com/110602224/201351507-e11ad543-47fc-4f18-8f85-eb5b71c8df29.png)

Con accesso a un sistema come utente con permessi sufficienti per avviare e fermare i servizi, è possibile alterare le sessioni RDP di altri utenti loggati via RDP.  
![image](https://user-images.githubusercontent.com/110602224/201352006-6d265845-b3d6-4044-ab9f-ec2a2da83352.png)

I valori importanti di cui prendere nota sono l'ID e il nome della sessione.  
A questo punto si crea un servizio che sfrutta la funzionalità [tscon](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/tscon).  
![image](https://user-images.githubusercontent.com/110602224/201352393-aff7b8d7-3058-4cbd-86c5-21db19369564.png)

Una volta avviato il servizio la sessione target è unita alla sessione corrente dell'hacker.  
Tecnica utile quando sono concesse connessioni RDP multiple per utente.  
Eliminare il servizio appena creato quando l'attacco cessa.  
![image](https://user-images.githubusercontent.com/110602224/201352690-b53602a7-8e9f-44a8-abd5-09827c1f2466.png)

Le credenziali RDP si possono ottenere intercettando le chiamate di funzione (function calls = API Hooking) in [mstsc.exe](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/mstsc), il file binario nativo di Windows che crea le connessioni ai Remote Desktop Services.  
Per questa tecnica servono:  
- [RemoteViewing](https://github.com/FuzzySecurity/Sharp-Suite): crea l'hook sulle funzioni in mstsc.exe per estrarre le credenziali e salvare in un file  
- [Donut](https://github.com/TheWover/donut): crea una shellcode da RemoteViewing da inserire nei processi mstsc.  
- Shellcode Injector: creare un shellcode injector personalizzato che controlla la presenza di nuovi processi mstsc e vi inietta la RemoteViewing shellcode  

![image](https://user-images.githubusercontent.com/110602224/201355970-331e8f6e-ab6e-4729-a105-67118a2bdaf4.png)
![image](https://user-images.githubusercontent.com/110602224/201356086-08cb58cb-7197-4c4e-9a76-3f4c052c513a.png)
![image](https://user-images.githubusercontent.com/110602224/201356182-3476f74a-c758-48e6-9023-06f7a50b62d7.png)
![image](https://user-images.githubusercontent.com/110602224/201356283-7d882df8-82ef-482c-992f-84649edb7707.png)

A questo punto si passa alla creazione del RemoteViewingInjector ch compia le seguenti azioni:  
- verifichi la presenza di nuovi processi mstsc ogni 5 secondi
- se sono individuati nuovi processi:
- - controlla se il PID corrisponde a un processo già compromesso
- - se il PID è nuovo, inietta la shellcode RemoteViewing
- - aggiungere il PID a una lista di proessi già compromessi

Per iniettare la shellcode sono necessarie le suguenti API di Windows:  
- [OpenProcess](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess) per aprire il processo remoto
- [VirtualAllocEx](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex) per allorace memoria nel processo remoto con permessi PAGE_EXECUTE_READWRITE
- [WriteProcessMemory](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory) copia la shellcode RemoteViewing nella memoria del processo target
- [CreateRemoteThread](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread) exegue la shellcode nel processo remoto

Link: https://www.pinvoke.net/  
![image](https://user-images.githubusercontent.com/110602224/201357858-196c168d-6e5f-441b-acaf-f111562d4a62.png)
![image](https://user-images.githubusercontent.com/110602224/201357910-7e3babf2-937f-4fd9-9113-ebfe7bcfe2d4.png)
![image](https://user-images.githubusercontent.com/110602224/201357959-c2e16ab4-4dff-4c72-b4dc-b0bfba10e066.png)

Link: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/  
![image](https://user-images.githubusercontent.com/110602224/201358046-69b07eca-1231-4cc2-9c06-05e3418ccbb6.png)
![image](https://user-images.githubusercontent.com/110602224/201358121-16f5f8b7-3b3e-4f2f-8db7-0b84ea5fb9c2.png)

Link: https://github.com/FuzzySecurity/Sharp-Suite/tree/master/RemoteViewing/Clairvoyant  
![image](https://user-images.githubusercontent.com/110602224/201358268-11b45139-cc3e-4023-abd6-27c58d934692.png)
![image](https://user-images.githubusercontent.com/110602224/201358329-f6079180-dcf9-42a0-a72e-918d4478583a.png)
![image](https://user-images.githubusercontent.com/110602224/201358401-c3bcd4c4-efa9-4588-86a1-96c6dff3de3d.png)
![image](https://user-images.githubusercontent.com/110602224/201358440-23d03ece-2657-4fb3-966e-61d593d8ea1e.png)
![image](https://user-images.githubusercontent.com/110602224/201358489-f43dd9f4-e20a-45c6-ac18-f8833fef5f81.png)
![image](https://user-images.githubusercontent.com/110602224/201358547-1695e6e2-128b-4794-b2da-dc7419c68be5.png)
![image](https://user-images.githubusercontent.com/110602224/201358583-4213c489-2bf8-45b2-a460-61d3a90ab9b0.png)
![image](https://user-images.githubusercontent.com/110602224/201358635-cd6cf679-b910-4ee9-a0ba-302cf28d3ba7.png)


### Browser Pivoting
Questa tecnica consiste nel dirottare il traffico del bwser dell'hacker attraverso il browser della vittima sfruttando un proxy HTTP e reindirizzando tutto il traffico web.  
L'hacker "eredita" il security context, i certificati e i cookie dell'utente e può quindi accedere a risorse internet (intranet) o esterne impersonando la vttima.  
L'estensione [CursedChrome](https://github.com/mandatoryprogrammer/CursedChrome) trasforma il browser Chrome in un proxy HTTP.  
L'estensione ha un portale di gestione all'indirizzo 127.0.0.1:8118 per gestire le istanze di Chrome e ottenere le credenziali proxy HTTP.  
All'indirizzo 127.0.0.1:8080 crea il Server Proxy, usando le credenziali delle istanze chrome (dal pannello admin), il traffico è reindirizzato attraverso il browser della vittima.  
Infine, all'indirizzo 127.0.0.1:4343 crea il Server WebSocket per la comunicazione con le istanze chrome della vittima.  
![image](https://user-images.githubusercontent.com/110602224/201364799-4b764c1c-6636-47d3-9ba6-80e821255e72.png)

Per installare CUrsedChrome è prima necessario installare [docker-compose](https://docs.docker.com/compose/install/) e clonare la repository git.  
![image](https://user-images.githubusercontent.com/110602224/201365264-50150b4f-2ca9-47b3-8bcc-66a184d63f77.png)

![image](https://user-images.githubusercontent.com/110602224/201365491-189628f3-705e-430c-9cb5-8a64fb278115.png)
![image](https://user-images.githubusercontent.com/110602224/201365608-836a81d8-05bc-4f4b-9516-a2a75eb2d568.png)
![image](https://user-images.githubusercontent.com/110602224/201365692-93da87fe-bd55-4ef1-9ca1-7247a98cf1ad.png)
![image](https://user-images.githubusercontent.com/110602224/201365746-33ebb5b4-a5f8-4861-83f7-00fbc0b67af4.png)
![image](https://user-images.githubusercontent.com/110602224/201365871-c70538cb-5b11-4f2c-9b03-324435c3b3f7.png)
![image](https://user-images.githubusercontent.com/110602224/201365940-d89b515a-6ec2-4cdc-aa09-d2c9a196c0b0.png)
![image](https://user-images.githubusercontent.com/110602224/201365986-7b4af62d-fc37-44ff-8d0d-22b27c3f06b1.png)
![image](https://user-images.githubusercontent.com/110602224/201366047-40850c82-361f-450e-8fba-46bf959e4b65.png)  
Link: https://addons.mozilla.org/en-US/firefox/addon/foxyproxy-standard/  
![image](https://user-images.githubusercontent.com/110602224/201366290-e5d43f18-8372-4d48-bca4-8b84def0ea74.png)


### SCShell
Il tool [SCShell](https://github.com/SpiderLabs/SCShell) permette una fileless lateral movement in quanto sfrutta la funzione [ChangeServiceConfigA](https://learn.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-changeserviceconfiga) per eseguire comandi senza autenticarsi via SMB ma via [DCERPC](https://en.wikipedia.org/wiki/DCE/RPC).  

Non registra e non crea nuovi servizi e non lascia tracce o file nei sistemi remoti.  
Funziona aprendo da remoto un servizio e modificando il binary path name che invoca la funzione ChaneServiceConfigA.  
![image](https://user-images.githubusercontent.com/110602224/201371243-593de8d9-e379-4be8-8e77-d879ee8087a6.png)

Il subtool [SCShell.py](https://github.com/SpiderLabs/SCShell/blob/master/scshell.py) di Impacker offre le stesse funzionalità e qualcosa in più come il supporto per Pass-the-Hash o Autenticazione Kerberos.  
La versione in C richiede mimikatz per funzionare.  

Un risultato simile si ottiene anche con WMI.  
![image](https://user-images.githubusercontent.com/110602224/201371727-3bad88d2-7d01-4a88-93b5-6bef378475d4.png)


### WinRM
Windows Remote Management è l'implementazione Microsoft  del protocollo [WS-Management](https://en.wikipedia.org/wiki/WS-Management).  
Usa WMI su HTTP(S) sulle porte TCP 5985 e 5986.  
WinRM richiede la presenza di listener sia nel server sia nel client attivabile usando il comando Powershell **Enable-PSRemoting -Force** sia localmente che nel sistem remoto.  
Alcuni tool interessanti da usare per lateral movement con WinRM sono:  
- [winrs](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/winrs)
- [Enter-PSSession](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/enter-pssession?view=powershell-7.3&viewFallbackFrom=powershell-6) ovvero Powershell Remoting basato su WinRM
- [Evil-WinRM](https://github.com/Hackplayers/evil-winrm)
- modulo di Metasploit [/auxiliary/scanner/winrm7winrm\_cmd](https://github.com/rapid7/metasploit-framework/blob/master/documentation/modules/auxiliary/scanner/winrm/winrm_cmd.md)  

![image](https://user-images.githubusercontent.com/110602224/201373079-6155d0bb-aa79-464d-a81e-bc5807cfad49.png)  

[WSMan-WinRM](https://github.com/bohops/WSMan-WinRM) è una collezione di codici sorgente e script per l'esecuzione di comandi via WinRM usando l'oggetto COM WSMan.Automation.  
Nell'esempio che segue si prende in esame _ShawpWSManWinRM.cs_.  
![image](https://user-images.githubusercontent.com/110602224/201373763-7129dc12-f832-4a1c-8e03-46e328061bb3.png)
![image](https://user-images.githubusercontent.com/110602224/201373825-badea018-03e7-40fd-a43e-b7aee38ab642.png)
![image](https://user-images.githubusercontent.com/110602224/201373854-e3e810c0-1c0e-47b3-b521-aab08eb5329e.png)
![image](https://user-images.githubusercontent.com/110602224/201373884-10a2b826-b4a7-4004-a343-55fdf480917e.png)
![image](https://user-images.githubusercontent.com/110602224/201373911-183d309d-3c12-44f9-810f-a69d91a66662.png)


### DCOM
L'acronimo COM sta per Component Object model e si tratta di un protocollo per l'intercomunicazione tra processi ma non supporta le comunicazioni di rete.  
DCOM, Distributed Component Object Model, supporta i protocolli di rete ma è facilmente bloccato dal Firewall di Windows.  
Risorse utili per sfruttare DCOM:  
- [dcomexec.py](https://github.com/SecureAuthCorp/impacket) di Impacket
- [SharpExcel4-DCOM](https://github.com/rvrsh3ll/SharpExcel4-DCOM)
- [Invoke-DCOM](https://github.com/rvrsh3ll/Misc-Powershell-Scripts/blob/master/Invoke-DCOM.ps1)
- [DCOMRade](https://github.com/sud0woodo/DCOMrade)

![image](https://user-images.githubusercontent.com/110602224/201384249-293c4a74-2376-489c-bf1c-afd8583e53f0.png)


### Named Pipes
Il modulo [Invoke-Pbind del Framework C2 PoshC2](https://github.com/nettitude/PoshC2/blob/master/resources/modules/Invoke-Pbind.ps1) crea una bind shell usando i named pipes per comunicare.  
![image](https://user-images.githubusercontent.com/110602224/201385850-d519e5da-18f4-4adc-8716-bf9fe603ac47.png)


### Powershell Web Access
PowerShell Web Access fu introdotto in Windows Server 2012 per offrire console di Powershell web-based.  
In questo modo si possono eseguire comandi d Powershell via browser senza configurare Powershell o plug-in nel computer remoto.  
I requisiti sono:  
- accesso admin nella macchina
- powershell versione 3+
- installazione di PSWA
- conifgurazione di un gateway PSWA
- traffico inbound su porta 443 ammesso

![image](https://user-images.githubusercontent.com/110602224/201387065-6331760a-8ad9-49f4-82f2-2cb9e5db7be8.png)
![image](https://user-images.githubusercontent.com/110602224/201387089-d9029342-08ff-4418-a67c-56a04871c072.png)
![image](https://user-images.githubusercontent.com/110602224/201387177-d48678de-918d-46c7-955e-aa6f9fb4a8a6.png)
![image](https://user-images.githubusercontent.com/110602224/201387215-2ce05789-dec8-4fe9-b589-dbdf46379d0c.png)


### Net-NTLM Relaying
L'Authentication Protocol [NT Lan Manager (NTLM)](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/b38c36ed-2804-4868-a9ff-8dd3182128e4) è usato nel processo di autenticazione tra utenti remoti, tra client e server, e garantisce un layers di sicurezza alla sessione quando richiesto dall'applicazione.  

Contrariamente a quanto accade con le hash NTLM, con le hash Net-NTLM non è possibile sfruttare l'attacco Pass-the-Hash.  
Le hash Net-NTLM si possono forzare offline o usarle in un attacco di relay se SMB Signing è disattivato... tool utili in quest'ultimo tipo di attacco:  
- [crackmapexec](https://github.com/Porchetta-Industries/CrackMapExec): genera una lista di host con SMB Signing disattivato  
- [Responder](https://github.com/lgandx/Responder): poisoner di LLMNR/NBT-NS/mDNS e relay per NTLMv1/v2  
- [ntlmrelayx di Impacket](https://github.com/SecureAuthCorp/impacket/blob/master/examples/ntlmrelayx.py): usato per relay delle hash Net-NTLM  
- [Reverse shell con Powershell](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md#powershell)  

Comando crackmapexec per generare elenco di host nella rete che usano SMBv1 e hanno SMB Signing disattivato: **crackmapexecsmb [CIDR] --gen-relay-list [OUTPUT FILE]**  
![image](https://user-images.githubusercontent.com/110602224/201610998-355d85f7-8855-49ba-bbf1-0b4ca54d24c1.png)  

Esempio di Payload in Powershell (reverse shell)  
![image](https://user-images.githubusercontent.com/110602224/201617701-93524ffc-4bda-40c5-b457-4c959e7a27bf.png)

Comandi per avviare un server http /web server per hostare il file con payload  
![image](https://user-images.githubusercontent.com/110602224/201617896-979a22f1-a8d7-4bfd-bceb-76b1263beced.png)

Disattivare i server HTTP e SMB nella configurazione di Responder.  
![image](https://user-images.githubusercontent.com/110602224/201620000-b2734d26-ea2f-475f-b832-df9fac9ab2ca.png)  
Dopo questa modifica ntlmrelayx è pronto per interrogare la lista di client estrapolata nei passaggi precedenti ed eseguire il comando.  
Se non si specifica il comando, il tool esegue lo script secretsdump.py per estrarre le hash delle password presenti nella macchina.  

![image](https://user-images.githubusercontent.com/110602224/201623475-240a57d7-bb92-4b4f-bb29-35547468cc4a.png)

Avviare Responder per avvelenare la rete e attendere che intercetti un tentativo di autenticazione.  
![image](https://user-images.githubusercontent.com/110602224/201623695-6fe1279a-5b96-41a0-b39e-389043ebf479.png)

![image](https://user-images.githubusercontent.com/110602224/201623754-18000fab-9a11-4418-a37f-c5a528f63098.png)

![image](https://user-images.githubusercontent.com/110602224/201623925-604d8da9-8440-4958-a757-aaa9ab4d6213.png)

Una volta che l'utente è autenticato, ntlmrelayx esegue il comando nella target e si ottiene una reverse shell come SYSTEM.  
![image](https://user-images.githubusercontent.com/110602224/201624238-4d11599d-8b3c-4ec3-b2a7-061ef71fd932.png)

### Computer Accounts
Gli account computer possono essere usati per lateral movement in quanto sono security principal come utenti e gruppi, hanno attributi come membership, security identifier...  
Gli account computer ruotano le password ogni 30 giorni per default rendendo le hash e password NTLM candidati di poco spessore per lateral movement.  
Per ovviare la prolema:  
![image](https://user-images.githubusercontent.com/110602224/201625382-74ad5df7-da6c-41f7-91db-2bf4655c82af.png)
![image](https://user-images.githubusercontent.com/110602224/201625540-de225475-6919-447c-9c59-c2da80120f92.png)
![image](https://user-images.githubusercontent.com/110602224/201625658-6ccfb907-2bed-495a-bb66-5ff7452690ef.png)
![image](https://user-images.githubusercontent.com/110602224/201626507-b8aca0f0-db12-41e0-a6b9-8b75bb189eb8.png)
![image](https://user-images.githubusercontent.com/110602224/201626656-63aab944-d03e-4162-81ca-f3dcb5f71277.png)
![image](https://user-images.githubusercontent.com/110602224/201626957-ec4327b1-60ce-4e6d-bccb-7465c8ba024d.png)  
Link: https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/winrs
![image](https://user-images.githubusercontent.com/110602224/201627155-69bb9dce-710b-440c-aea1-6a25f6fa00bd.png)

Ogni utente autenticato può aggiungere al dominio 10 computer come comportamento predefinito, grazie all'attributo ms-DS-MachineAccountQuota.  
Questo comportamento è sfruttabile per creare account computer falsi senza scadenza della password.  
Il tool [PowerMAD](https://github.com/Kevin-Robertson/Powermad) aiuta nella creazione di falsi account computer che una volta aggiunti al gruppo di Local Administrators assicurano una forma di persistence.  
![image](https://user-images.githubusercontent.com/110602224/201628118-a3550898-360f-40d6-ace4-a68b9f01cb61.png)
![image](https://user-images.githubusercontent.com/110602224/201628190-60a1ccaf-9d64-4ec5-9c06-b4d89d0515c6.png)

Comando per aggiungere l'account falso al gruppo di amministratori locali:  
![image](https://user-images.githubusercontent.com/110602224/201628429-f0c534c1-1536-4cae-8b16-716de5f9e8ef.png)
![image](https://user-images.githubusercontent.com/110602224/201628482-b70e5f32-52e2-4d2e-8a4c-c6e2bacba7c7.png)
![image](https://user-images.githubusercontent.com/110602224/201628634-0311e414-91f0-4ce1-b4de-585a041ecd57.png)

Gli account computer possono creare i Silver Ticket.  
![image](https://user-images.githubusercontent.com/110602224/201628904-b9c81cdb-afd1-442a-af70-bf39351ba54e.png)
![image](https://user-images.githubusercontent.com/110602224/201628944-3574016e-4438-49e8-aee4-77d8daaae878.png)


